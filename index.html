<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Word Shooter</title>
    
    <!-- Open Graph -->
    <meta property="og:title" content="ðŸš€ Word Shooter">
    <meta property="og:image" content="https://wordshooter.vercel.app/og-image.png">
    <meta property="og:url" content="https://wordshooter.vercel.app/">
    <meta property="og:type" content="website">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ðŸš€ Word Shooter">
    <meta name="twitter:image" content="https://wordshooter.vercel.app/og-image.png">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸš€</text></svg>">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">
    <style>
        /* Force Material Symbols to block-render and never show fallback text */
        .material-symbols-outlined {
            font-family: 'Material Symbols Outlined' !important;
            font-weight: normal;
            font-style: normal;
            font-size: 18px;
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-feature-settings: 'liga';
            font-feature-settings: 'liga';
            -webkit-font-smoothing: antialiased;
            font-display: block;
            /* Hide text until font loads */
            color: transparent;
            transition: color 0.1s;
        }
        /* Once font is loaded (class added by JS), show icons */
        .icons-loaded .material-symbols-outlined {
            color: white;
        }
        /* Fallback: after 2s always show */
        .material-symbols-outlined {
            animation: showIcon 0s 2s forwards;
        }
        @keyframes showIcon {
            to { color: white; }
        }
    </style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
            overscroll-behavior: none;
            background: #000814;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            color: white;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            -webkit-overflow-scrolling: touch;
            touch-action: none;
            overscroll-behavior: none;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(1px 1px at 15% 55%, white, transparent),
                radial-gradient(2px 2px at 70% 25%, white, transparent),
                radial-gradient(1px 1px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 25% 90%, white, transparent);
            background-size: 200% 200%, 300% 300%, 250% 250%, 280% 280%, 220% 220%, 
                             260% 260%, 290% 290%, 240% 240%, 270% 270%, 230% 230%;
            background-position: 0% 0%, 40% 60%, 50% 50%, 80% 10%, 90% 60%, 
                                 33% 80%, 15% 55%, 70% 25%, 45% 15%, 25% 90%;
            background-repeat: repeat;
            opacity: 0.6;
            z-index: 0;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Use dynamic viewport height for mobile browsers */
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            z-index: 1;
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            overflow: hidden;
            touch-action: none;
        }

        #starCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #gameContainer.hidden {
            display: none;
        }

        /* Top side - Invader area */
        #topSide {
            width: 100%;
            height: 70%;
            position: relative;
            background: linear-gradient(to bottom, #16213e, transparent);
        }

        /* Bottom side - Spaceship area */
        #bottomSide {
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, #0f3460, transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 500;
        }
        
        /* Create a mask to hide lasers below the rocket */
        #bottomSide::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, 
                radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%) 0%, 
                transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        #gun {
            font-size: 80px;
            transform: rotate(-45deg);
            transition: transform 0.3s ease;
            position: relative;
            z-index: 510;
        }

        #gun.shoot {
            transform: rotate(-45deg) scale(1.2);
        }

        #gun.aiming {
            transition: transform 0.3s ease;
        }

        #inputDisplay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) scale(0.85);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px 30px;
            font-size: 24px;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            letter-spacing: 2px;
            transition: all 0.3s ease;
            transform-origin: center;
            /* Show by default on desktop */
            opacity: 1;
            visibility: visible;
            z-index: 510;
        }
        
        /* Hide when empty (no content) */
        #inputDisplay:empty {
            opacity: 0;
            visibility: hidden;
        }

        #inputDisplay.active {
            transform: translateX(-50%) scale(1);
            min-width: 300px;
        }

        #inputDisplay .typed {
            color: white;
            opacity: 1;
        }

        #inputDisplay .untyped {
            color: white;
            opacity: 0.3;
        }

        #inputDisplay.error {
            animation: inputShake 0.3s;
            border-color: rgba(255, 68, 68, 0.6);
            background: rgba(255, 68, 68, 0.1);
        }

        @keyframes inputShake {
            0%, 100% { transform: translateX(-50%) scale(1); }
            25% { transform: translateX(calc(-50% - 5px)) scale(1); }
            75% { transform: translateX(calc(-50% + 5px)) scale(1); }
        }

        /* Hidden mobile input for keyboard */
        #mobileInput {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            opacity: 0.01;
            z-index: 9999;
            border: none;
            background: transparent;
            color: transparent;
            font-size: 16px;
            caret-color: transparent;
            pointer-events: auto;
        }
        
        #mobileInput:focus {
            outline: none;
        }
        
        /* On-screen keyboard - HIDDEN ON DESKTOP */
        #onScreenKeyboard {
            display: none;
            flex-direction: column;
            gap: 0;
            padding: 0;
            padding-bottom: env(safe-area-inset-bottom);
            background: transparent;
            border-radius: 0;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 510;
        }
        
        /* Hide normal keyboard during challenge */
        #onScreenKeyboard.hide-for-challenge {
            display: none !important;
        }
        
        /* Number keyboard for math mode */
        #numberKeyboard {
            display: none;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: transparent;
            border-radius: 0;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 510;
        }
        
        #numberKeyboard.show {
            display: flex;
        }
        
        #numberKeyboard .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 0;
        }
        
        #numberKeyboard .key {
            width: calc(100% / 5);  /* 5 keys per row */
            height: 52px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            border-right: 0.5px solid rgba(255, 255, 255, 0.1);
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
        }
        
        #numberKeyboard .key:active {
            background: rgba(16, 185, 129, 0.5);
            transform: scale(0.95);
        }
        
        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 0;  /* No gap - keys will be sized by media queries */
        }
        
        .key {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .key:active {
            background: rgba(16, 185, 129, 0.5);
            transform: scale(0.95);
        }

        .key-space {
            width: 100%;
            font-size: 12px;
            letter-spacing: 2px;
        }

        #spacebarRow {
            width: 100%;
        }
        
        .key.pressed {
            background: rgba(255, 215, 0, 0.7) !important;
            border-color: rgba(255, 215, 0, 1) !important;
        }
        
        .key.active {
            background: rgba(22, 160, 133, 0.7) !important;
            border-color: rgba(22, 160, 133, 1) !important;
        }
        
        /* Show keyboard ONLY on mobile */
        @media (max-width: 1024px), (pointer: coarse) {
            #onScreenKeyboard {
                display: flex;
                gap: 0;  /* Remove gap between rows */
                padding: 0;  /* Remove all padding - attach to bottom */
            }
            
            #numberKeyboard {
                /* Keep hidden by default, shown when math mode activates */
            }
            
            #mobileInput {
                display: none;
            }
            
            #inputDisplay {
                bottom: 230px;
                /* Always hide on mobile/tablet since we show keyboard */
                display: none !important;
            }
            
            .keyboard-row {
                gap: 0;  /* Remove gap between keys */
            }
            
            .key {
                width: calc(100% / 10);  /* 10 keys in first row - equal width */
                height: 52px;  /* Increased height */
                font-size: 18px;
                border-radius: 0;  /* Remove border radius for seamless look */
                border-right: 0.5px solid rgba(255, 255, 255, 0.1);  /* Subtle separator */
                border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            }
            
            .keyboard-row:first-child .key {
                width: calc(100% / 10);  /* 10 keys */
            }
            
            .keyboard-row:nth-child(2) .key {
                width: calc(100% / 9);  /* 9 keys */
            }

            .keyboard-row:nth-child(3) .key {
                width: calc(100% / 7);  /* 7 keys, full width */
            }

            #spacebarRow {
                width: 100%;
            }

            #spacebarRow .key-space {
                width: 100%;
                height: 52px;
                font-size: 12px;
                border-radius: 0;
                border-right: none;
                border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
                letter-spacing: 2px;
            }
        }
        
        @media (max-width: 480px) {
            .key {
                height: 50px;  /* Slightly smaller for small screens */
                font-size: 16px;
            }
            
            #onScreenKeyboard {
                gap: 0;
                padding: 0;
            }
            
            #inputDisplay {
                bottom: 210px;
            }
            
            #gun {
                font-size: 40px;
                margin-bottom: 160px;
            }

            #spacebarRow .key-space {
                height: 50px;
            }
        }
        
        @media (max-width: 375px) {
            .key {
                height: 48px;
                font-size: 14px;
            }
            
            #onScreenKeyboard {
                gap: 0;
                padding: 0;
            }
            
            #inputDisplay {
                bottom: 200px;
            }

            #spacebarRow .key-space {
                height: 48px;
            }
        }

        /* Invader styling */
        .invader {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .invader-emoji {
            font-size: 40px;
            margin-bottom: 5px;
        }

        .invader-word {
            background: rgba(255, 255, 255, 0.8);
            color: #16213e;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            --progress: 0%;
        }

        .invader-word::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--progress);
            background: rgba(16, 185, 129, 0.8);
            transition: width 0.1s ease;
            z-index: 0;
            border-radius: 15px;
        }

        .invader-word .char {
            position: relative;
            z-index: 1;
        }

        .invader-word.typing {
            background: rgba(16, 185, 129, 0.8) !important;
            color: white;
        }

        .invader-word.typing::before {
            width: 110% !important;  /* Extend beyond 100% to ensure full coverage */
            transition: none;  /* Remove transition delay on completion */
        }

        .invader.dying {
            animation: die 0.5s forwards;
        }
        
        /* Keep green color when matched invader is dying - HIGH SPECIFICITY */
        .invader.dying .invader-word.typing {
            background: rgba(16, 185, 129, 0.8) !important;
            color: white !important;
        }
        
        /* Also ensure emoji container doesn't interfere */
        .invader.dying .invader-emoji {
            opacity: 1;
        }
        
        /* Hide the progress ::before element when completed to show solid green background */
        .invader.dying .invader-word.typing::before,
        .invader-word.typing::before {
            display: none !important;
        }
        
        /* Ensure the green stays during the entire fade animation */
        @keyframes die {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        /* Force green to persist on dying invaders with typing class */
        .invader.dying > .invader-word.typing {
            background-color: rgba(16, 185, 129, 0.8) !important;
        }

        /* Bullet styling */
        .bullet {
            position: absolute;
            width: 3px;
            height: 0px;
            background: linear-gradient(to bottom, 
                rgba(255, 50, 50, 1) 0%,
                rgba(255, 100, 100, 0.9) 50%,
                rgba(255, 50, 50, 1) 100%);
            box-shadow: 
                0 0 10px rgba(255, 50, 50, 0.8),
                0 0 20px rgba(255, 50, 50, 0.6),
                0 0 30px rgba(255, 50, 50, 0.4);
            z-index: 100;
            transform-origin: top center;
            pointer-events: none;
        }
        
        .bullet::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, 
                rgba(255, 255, 255, 1) 0%,
                rgba(255, 100, 100, 1) 40%,
                rgba(255, 50, 50, 0.8) 70%,
                transparent 100%);
            border-radius: 50%;
            box-shadow: 
                0 0 15px rgba(255, 50, 50, 1),
                0 0 25px rgba(255, 50, 50, 0.8);
        }

        /* Topbar Container */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            padding-top: calc(8px + env(safe-area-inset-top));
            z-index: 1000;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        #topbar.show {
            display: flex;
        }

        #leftControls {
            display: flex;
            gap: 7.5px;  /* Reduced by half (was 15px) */
            align-items: center;
        }

        #rightControls {
            display: flex;
            gap: 7.5px;  /* Reduced by half (was 15px) */
            align-items: center;
        }

        /* Shared pill â€” one source of truth so ALL topbar pills are identical height */
        .topbar-pill {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0 10px;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            box-sizing: border-box;
            white-space: nowrap;
        }

        /* UI Elements */
        #score {
            justify-content: flex-start;
            gap: 5px;
        }

        #scoreValue {
            position: relative;
            display: inline-block;
            transition: color 0.3s ease;
        }

        #scoreValue.score-increase {
            animation: scoreUp 0.5s ease-out;
        }

        #scoreValue.score-decrease {
            animation: scoreDown 0.5s ease-out;
            color: #ff4444;
        }

        @keyframes scoreUp {
            0% {
                transform: scale(1.3);
                opacity: 0.7;
                color: #4ecca3;
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                color: inherit;
            }
        }

        @keyframes scoreDown {
            0% {
                transform: scale(1.3);
                opacity: 0.7;
                color: #ff4444;
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                color: #ff4444;
            }
        }

        #difficultyDisplay {
            /* unique: nothing extra needed */
        }

        #difficultyDisplay:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #speedDisplay {
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
        }

        #speedDisplay:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #categoryDisplay {
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        #categoryDisplay:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #celebrationPreviewBtn {
            background: rgba(255, 215, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 215, 0, 0.35);
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #celebrationPreviewBtn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
            color: #FFD700;
        }

        #celebrationPreviewBtn:hover {
            background: rgba(255, 215, 0, 0.25);
            transform: scale(1.05);
        }

        #pauseBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;  /* Reduced from 40px to match tablet */
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 16px to match tablet */
            font-weight: bold;
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pauseBtn .material-symbols-outlined {
            font-size: 18px;  /* Increased to 18px (was 16px) */
            line-height: 1;
        }

        #pauseBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #restartGameBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;  /* Reduced from 40px to match tablet */
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 16px to match tablet */
            font-weight: bold;
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #restartGameBtn .material-symbols-outlined {
            font-size: 18px;  /* Increased to 18px (was 16px) */
            line-height: 1;
        }

        #restartGameBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #homeBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #homeBtn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
        }

        #homeBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #muteBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #muteBtn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
        }

        #muteBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Game Over Screen */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile */
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow: hidden;
        }

        #gameOver.show {
            display: flex;
        }

        #gameOver h1 {
            font-size: 72px;
            margin-bottom: 20px;
            color: #ff4757;
            text-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
        }

        #finalScore {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #restartBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            font-family: 'Press Start 2P', cursive;
        }

        #restartBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Celebration Screen */
        #celebrationScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overflow-y: auto;
            padding: 20px;
            pointer-events: auto;
        }

        /* Star field overlay for celebration screen */
        #celebrationScreen::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(1px 1px at 15% 55%, white, transparent),
                radial-gradient(2px 2px at 70% 25%, white, transparent),
                radial-gradient(1px 1px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 25% 90%, white, transparent);
            background-size: 200% 200%, 300% 300%, 250% 250%, 280% 280%, 220% 220%, 
                             260% 260%, 290% 290%, 240% 240%, 270% 270%, 230% 230%;
            background-position: 0% 0%, 40% 60%, 50% 50%, 80% 10%, 90% 60%, 
                                 33% 80%, 15% 55%, 70% 25%, 45% 15%, 25% 90%;
            background-repeat: repeat;
            opacity: 0.6;
            z-index: 0;
            pointer-events: none;
        }

        #celebrationTopBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            z-index: 3001;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            pointer-events: auto;
            gap: 7.5px;
        }
        
        #celebrationTopBar .celebration-title {
            font-size: 16px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(135deg, #ff8c00 0%, #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #celebrationTopBar .celebration-buttons {
            display: flex;
            gap: 7.5px;
        }

        .celebration-top-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .celebration-top-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .celebration-top-btn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
        }

        #celebrationCard {
            background: rgba(30, 45, 70, 0.98);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            width: 300px;
            /* Let the card hug its contents so graph + labels are never clipped */
            height: auto;
            /* Softer, subtler drop shadow */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }
        
        /* 3D Hover Effect */
        .hover-3d-wrapper {
            perspective: 1000px;
            display: inline-block;
        }
        
        .hover-3d {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease-out;
            will-change: transform;
        }
        
        /* Hide the 8 effect divs - they create color overlays */
        .hover-3d > div:not(#celebrationCard) {
            display: none;
        }

        #celebrationHeader {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .header-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .header-rank {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .header-value {
            font-size: 30px;
            font-family: 'Press Start 2P', cursive;
            color: #ffffff;
            line-height: 1;
        }

        #celebrationBody {
            padding: 16px 20px 20px 20px;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .left-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stat-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .stat-value {
            font-size: 32px;
            color: #ffd700;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 0 0 6px rgba(255, 215, 0, 0.2);
            line-height: 1;
        }

        /* Match accuracy color with the graph (green) */
        #celebrationAccuracy {
            color: #10b981;
            text-shadow: 0 0 6px rgba(16, 185, 129, 0.2);
        }

        #celebrationRocketIcon {
            position: absolute;
            right: 20px;
            top: 32px;
            font-size: 56px;
            opacity: 0.95;
            animation: rocketFloat 3s ease-in-out infinite;
        }

        @keyframes rocketFloat {
            0%, 100% { transform: translateY(0) rotate(-25deg); }
            50% { transform: translateY(-12px) rotate(-25deg); }
        }

        .bottom-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: flex-start;
            padding: 0 0px;
        }

        .bottom-stats-left,
        .bottom-stats-right {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bottom-stats-right {
            text-align: right;
        }

        .bottom-stat-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .bottom-stat-value {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        /* Journey mode celebration tabs */
        #journeyTabs {
            display: none;
            flex-direction: column;
            margin-bottom: 8px;
        }

        .journey-tab-nav {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .journey-tab-btn {
            flex: 0 0 auto;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 8px;
            padding: 6px 6px;
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            color: rgba(255,255,255,0.45);
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .journey-tab-btn.active {
            background: rgba(255,255,255,0.14);
            border-color: rgba(255,255,255,0.35);
            color: #fff;
        }

        .journey-tab-content {
            display: none;
        }

        .journey-tab-content.active {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 12px;
        }

        .journey-stat-block {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .journey-stat-block.full-width {
            grid-column: 1 / -1;
        }

        .journey-stat-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            color: rgba(255,255,255,0.45);
            line-height: 1.3;
        }

        .journey-stat-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #ffd700;
            text-shadow: 0 0 6px rgba(255, 215, 0, 0.2);
            line-height: 1;
        }

        .graph-container {
            margin-top: 8px;
        }

        #scoreboardLink {
            text-align: center;
            padding: 12px 0 4px;
        }

        #playAgainLink {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #ffffff;
            line-height: 1.2;
            text-decoration: underline;
            cursor: pointer;
            display: inline-block;
            animation: playAgainPulse 1.5s ease-in-out infinite;
        }

        @keyframes playAgainPulse {
            0%, 100% { opacity: 0.4; }
            50%       { opacity: 1.0; }
        }

        #playAgainLink:hover {
            opacity: 1;
            animation: none;
        }

        #graphViewToggle {
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
        }

        #btnViewToggle {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.07);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 6px 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        #btnViewToggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
            color: #ffffff;
            transform: scale(1.05);
        }

        #speedometerCanvas {
            width: 100%;
            display: block;
        }

        #graphView, #speedoView {
        }

        #performanceGraph {
            width: 100%;
            /* Slightly reduced height so labels + graph fit comfortably */
            height: 135px;
            display: block;
        }

        .graph-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* Extra padding-top to separate graph from time labels */
            padding: 8px 0px 0 0px;
        }

        .graph-time-label {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .graph-time-label.center {
            flex: 1;
            text-align: center;
        }

        @media (max-width: 1024px) {
            #celebrationCard {
                width: 280px;
                height: auto;
            }

            .header-label,
            .header-rank {
                font-size: 11px;
            }

            .header-value {
                font-size: 32px;
            }

            .stat-label {
                font-size: 9px;
            }

            .stat-value {
                font-size: 28px;
            }

            #celebrationRocketIcon {
                font-size: 48px;
                right: 18px;
                top: 28px;
            }

            #performanceGraph {
                /* Match desktop reduction (~10%) for mobile */
                height: 115px;
            }

            .bottom-stat-label,
            .bottom-stat-value {
                font-size: 9px;
            }
            
            .celebration-top-btn {
                width: 28px;
                height: 28px;
            }
            
            .celebration-top-btn .material-symbols-outlined {
                font-size: 16px;
            }
        }

        /* Pause Overlay */
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            cursor: pointer;
        }

        #pauseOverlay.show {
            display: flex;
        }

        #pauseContent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #pauseMicrocopy {
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #pauseIcon {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 20px;  /* Changed to accommodate text */
            border-radius: 10px;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        #pauseIcon:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        #pauseIcon .material-symbols-outlined {
            font-size: 23px;  /* 30% bigger than 18px */
            line-height: 1;
        }
        
        #pauseIcon .pause-text {
            font-size: 16px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
        }

        /* Challenge Screen */
        #challengeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.5);  /* 50% black instead of 95% */
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        #challengeScreen.show {
            display: flex;
        }

        #challengeContent {
            text-align: center;
            max-width: 90%;
            padding: 40px;
        }

        #challengeTimer {
            font-size: 28px;  /* Same size as title */
            color: #ff4757;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
        }

        #challengeTitle {
            font-size: 28px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #challengeSentence {
            font-size: 24px;
            color: white;
            margin-bottom: 20px;
            line-height: 1.6;
            letter-spacing: 2px;
        }

        #challengeSentence .char {
            position: relative;
        }

        #challengeSentence .char.correct {
            color: #10b981;
        }

        #challengeSentence .char.current {
            background: rgba(255, 215, 0, 0.3);
            animation: blink 0.8s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #challengeInput {
            display: none;
        }

        /* Challenge keyboard - hidden on desktop */
        #challengeKeyboard {
            display: none;
        }

        @media (max-width: 1024px) {
            #challengeTitle {
                font-size: 20px;
            }

            #challengeTimer {
                font-size: 20px;
            }

            #challengeSentence {
                font-size: 18px;
                letter-spacing: 1px;
            }

            #challengeInput {
                font-size: 14px;
            }

            #challengeContent {
                padding: 20px;
            }

            /* Show keyboard on mobile/tablet */
            #challengeKeyboard {
                display: flex;
                flex-direction: column;
                gap: 0;
                width: 100%;
                position: fixed;
                bottom: 0;
                left: 0;
                z-index: 3000;
            }

            .challenge-keyboard-row {
                display: flex;
                justify-content: center;
                gap: 0;
            }

            .challenge-key {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                font-size: 18px;
                font-weight: bold;
                font-family: 'Press Start 2P', cursive;
                height: 52px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 0;
                cursor: pointer;
                transition: all 0.1s;
                user-select: none;
                -webkit-user-select: none;
                -webkit-tap-highlight-color: transparent;
                border-right: 0.5px solid rgba(255, 255, 255, 0.1);
                border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            }

            .challenge-key:active {
                background: rgba(16, 185, 129, 0.5);
                transform: scale(0.95);
            }

            .challenge-keyboard-row:first-child .challenge-key {
                width: calc(100% / 10);
            }

            .challenge-keyboard-row:nth-child(2) .challenge-key {
                width: calc(100% / 9);
            }

            .challenge-keyboard-row:nth-child(3) .challenge-key {
                width: calc(100% / 8);  /* 8 keys now (removed space) */
            }

            .challenge-keyboard-row:nth-child(4) .challenge-key {
                width: 100%;  /* Full width spacebar */
            }

            .challenge-key.spacebar {
                width: 100%;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .challenge-key {
                height: 50px;
                font-size: 16px;
            }
        }

        @media (max-width: 375px) {
            .challenge-key {
                height: 48px;
                font-size: 14px;
            }
        }


        /* Time Selection Screen */
        #timeSelection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile */
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 20px;
        }
        
        /* Floating words background */


        #menuStarCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #timeSelection::before {
            display: none;
        }

        #timeSelection.hidden {
            display: none;
        }

        #startScreenContent {
            background: rgba(26, 41, 66, 0.05);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 20px 24px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.15);
            width: fit-content;
            max-width: calc(100vw - 40px);
            position: relative;
            z-index: 10;
        }

        #startScreenContent #rocketIcon {
            font-size: 36px;  /* Match tablet size */
            text-align: center;
            margin-bottom: 20px;
            animation: rotate360 8s linear infinite;
        }

        @keyframes rotate360 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #gameTitle {
            font-size: 16px;  /* Match tablet size */
            font-weight: bold;
            background: linear-gradient(135deg, #ff8c00 0%, #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            line-height: 1.2;
            margin-bottom: 10px;
        }

        #gameSubtitle {
            font-size: 9px;  /* Match tablet size */
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 40px;
        }

        #difficultyOptions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px;
            max-width: calc(100vw - 88px); /* 40px outer padding + 24px inner padding x2 */
        }

        .difficulty-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .difficulty-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        .difficulty-name {
            font-size: 13px;
            font-weight: bold;
            color: white;
            margin: 0;
            padding: 0;
            line-height: 1.2;
        }

        .difficulty-desc {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.4);
            margin: 0;
            padding: 0;
            line-height: 1.2;
        }

        .mode-emoji {
            font-size: 22px;
            opacity: 0;
            transform: scale(0.6);
            transition: opacity 0.2s ease, transform 0.2s ease;
            flex-shrink: 0;
            line-height: 1;
            margin-left: 10px;
            display: flex;
            align-items: center;
        }

        .difficulty-option:hover .mode-emoji {
            opacity: 1;
            transform: scale(1);
        }

        .difficulty-option:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: rgba(78, 205, 196, 0.6);
            transform: scale(1.05);
        }

        /* Sentences Mode Fixed Overlay */
        #sentencesOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 600;
            pointer-events: none;
            padding: 20px;
        }
        
        #sentencesOverlay.show {
            display: flex;
        }
        
        #sentencesBox {
            background: rgba(26, 41, 66, 0.92);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 20px 28px;
            max-width: 700px;
            width: 95%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transform: translateY(-50px);
        }
        
        #sentencesBox.animate-in {
            animation: sentence-slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        
        #sentencesBox.animate-out {
            animation: sentence-slide-out 0.35s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        
        @keyframes sentence-slide-in {
            from { opacity: 0; transform: translateY(-50px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes sentence-slide-out {
            from { opacity: 1; transform: translateY(0); }
            to   { opacity: 0; transform: translateY(50px); }
        }
        
        #sentencesDurationBar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            margin-bottom: 14px;
            overflow: hidden;
        }
        
        #sentencesDurationFill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #FFD700);
            border-radius: 2px;
            width: 100%;
        }

        #sentencesMeta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 14px;
        }

        #sentencesHint {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.35);
            font-family: 'Press Start 2P', cursive;
        }

        #sentencesTimer {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
        }
        
        #sentencesText {
            font-size: 18px;
            color: white;
            font-family: 'Press Start 2P', cursive;
            line-height: 1.8;
            letter-spacing: 1px;
            word-break: keep-all;
            overflow-wrap: normal;
            white-space: normal;
            margin-top: 14px;
        }
        
        #sentencesText .word {
            display: inline-block;
        }
        
        #sentencesText .char.correct {
            color: #10b981;
        }
        
        #sentencesText .char.current {
            background: rgba(255, 215, 0, 0.3);
            animation: blink 0.8s ease-in-out infinite;
        }
        
        @media (max-width: 1024px) {
            #sentencesText {
                font-size: 13px;
                letter-spacing: 0px;
            }
            #sentencesBox {
                padding: 14px 16px;
            }
        }



        .shake {
            animation: shake 0.5s;
        }

        /* Responsive adjustments */
        @media (max-width: 1024px) {
            body {
                overflow: hidden;
            }
            
            #gun {
                font-size: 50px;
                margin-bottom: 180px;
            }
            
            #inputDisplay {
                font-size: 16px;
                padding: 10px 20px;
                min-width: 150px;
                bottom: 15px;
            }
            
            #inputDisplay.active {
                min-width: 220px;
            }
            
            .invader-emoji {
                font-size: 28px;
            }
            .invader-word {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            #topbar {
                padding: 8px 12px;
            }
            
            /* Pills are already sized correctly via .topbar-pill */
            
            #pauseBtn, #restartGameBtn, #homeBtn, #muteBtn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }
            
            #pauseBtn {
                display: none;  /* Hide pause button on mobile */
            }
            
            #pauseBtn .material-symbols-outlined,
            #restartGameBtn .material-symbols-outlined,
            #homeBtn .material-symbols-outlined,
            #muteBtn .material-symbols-outlined {
                font-size: 18px;  /* Increased to 18px (was 16px) */
            }
            
            /* Game Over Screen Mobile */
            #gameOver h1 {
                font-size: 48px;
                margin-bottom: 15px;
            }
            
            #finalScore {
                font-size: 24px;
                margin-bottom: 25px;
            }
            
            #restartBtn {
                font-size: 16px;
                padding: 12px 30px;
            }
            
            /* Start Screen Mobile */
            #startScreenContent {
                padding: 20px 24px;  /* Reduced by 20% (was 25px 30px) */
                max-width: 90%;
            }
            
            #rocketIcon {
                font-size: 36px;  /* Reduced by 20% (was 45px) */
            }
            
            #gameTitle {
                font-size: 16px;  /* Reduced by 20% (was 20px in desktop, keeping proportion) */
            }
            
            #gameSubtitle {
                font-size: 9px;  /* Reduced proportionally */
            }
            
            .difficulty-option {
                padding: 12px 14px;  /* Reduced by 20% (was 15px 18px) */
            }
            
            .difficulty-name {
                font-size: 13px;
            }
            
            .difficulty-desc {
                font-size: 9px;
            }
        }
        
        @media (max-width: 480px) {
            #gun {
                font-size: 40px;
                margin-bottom: 160px;
            }
            
            #inputDisplay {
                font-size: 14px;
                padding: 8px 16px;
                min-width: 120px;
                bottom: 10px;
            }
            
            #inputDisplay.active {
                min-width: 180px;
            }
            
            .invader-emoji {
                font-size: 24px;
            }
            
            .invader-word {
                font-size: 10px;
                padding: 3px 7px;
            }
            
            #topbar {
                padding: 6px 10px;
            }
            
            .topbar-pill {
                font-size: 10px;
                padding: 0 8px;
                height: 28px;
            }

            #difficultyDisplay {
                /* covered by .topbar-pill above */
            }
            
            #categoryDisplay {
                /* covered by .topbar-pill above */
            }
            
            #score {
                /* covered by .topbar-pill above */
            }
            
            #pauseBtn, #restartGameBtn, #homeBtn, #muteBtn {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }
            
            #pauseBtn .material-symbols-outlined,
            #restartGameBtn .material-symbols-outlined,
            #homeBtn .material-symbols-outlined,
            #muteBtn .material-symbols-outlined {
                font-size: 14px;
            }
            
            #leftControls {
                gap: 10px;
            }
            
            #rightControls {
                gap: 10px;
            }
            
            /* Game Over Screen Small Mobile */
            #gameOver {
                padding: 20px;
            }
            
            #gameOver h1 {
                font-size: 36px;
                margin-bottom: 12px;
            }
            
            #finalScore {
                font-size: 20px;
                margin-bottom: 20px;
            }
            
            #restartBtn {
                font-size: 14px;
                padding: 10px 25px;
            }
            
            /* Start Screen Small Mobile */
            #startScreenContent {
                padding: 16px 20px;  /* Reduced by 20% (was 20px 25px) */
                max-width: 95%;
            }
            
            #startScreenContent #rocketIcon {
                font-size: 32px;  /* Reduced by 20% (was 40px) */
            }
            
            #gameTitle {
                font-size: 16px;  /* Keeping consistent with main mobile breakpoint */
            }
            
            #gameSubtitle {
                font-size: 8px;  /* Reduced by 20% (was 10px) */
            }
            
            #difficultyOptions {
                gap: 10px;  /* Reduced slightly (was 12px) */
            }
            
            .difficulty-option {
                padding: 12px 15px;
            }
            
            .difficulty-name {
                font-size: 13px;
            }
            
            .difficulty-desc {
                font-size: 8px;
            }
        }
        
        /* Extra small screens (iPhone SE, etc) */
        @media (max-width: 375px) {
            #gameOver h1 {
                font-size: 32px;
            }
            
            #finalScore {
                font-size: 18px;
            }
            
            #restartBtn {
                font-size: 12px;
                padding: 8px 20px;
            }
            
            #gameTitle {
                font-size: 14px;  /* Reduced by ~30% from 20px */
            }
            
            .difficulty-name {
                font-size: 11px;  /* Reduced slightly (was 13px) */
            }
        }
    </style>
</head>
<body>
    <div id="topbar">
        <div id="leftControls">
            <div id="score" class="topbar-pill">Score: <span id="scoreValue">0</span></div>
            <div id="difficultyDisplay" class="topbar-pill">Words</div>
            <div id="speedDisplay" class="topbar-pill">1x</div>
        </div>
        <div id="rightControls">
            <button id="autoTestToggle" style="background: #3b82f6; display: none;" title="Toggle Auto-Test Mode">
                <span style="font-size: 14px;">ðŸ¤– TEST</span>
            </button>
            <button id="gameShuffleBtn" title="Generate fake data & preview" style="display:none;">
                <span class="material-symbols-outlined">shuffle</span>
            </button>
            <button id="celebrationPreviewBtn" title="Preview Celebration" style="display:none;">
                <span class="material-symbols-outlined">emoji_events</span>
            </button>
            <button id="pauseBtn"><span class="material-symbols-outlined">pause</span></button>
            <button id="restartGameBtn"><span class="material-symbols-outlined">refresh</span></button>
            <button id="homeBtn"><span class="material-symbols-outlined">home</span></button>
            <button id="muteBtn"><span class="material-symbols-outlined">volume_up</span></button>
        </div>
    </div>

    <div id="gameContainer" tabindex="0">
        <canvas id="starCanvas"></canvas>
        <div id="topSide"></div>
        <div id="bottomSide">
            <div id="gun">ðŸš€</div>
            <div id="inputDisplay"></div>
            <input type="text" id="mobileInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            
            <!-- On-screen keyboard -->
            <div id="onScreenKeyboard">
                <div class="keyboard-row">
                    <button class="key" data-key="q">Q</button>
                    <button class="key" data-key="w">W</button>
                    <button class="key" data-key="e">E</button>
                    <button class="key" data-key="r">R</button>
                    <button class="key" data-key="t">T</button>
                    <button class="key" data-key="y">Y</button>
                    <button class="key" data-key="u">U</button>
                    <button class="key" data-key="i">I</button>
                    <button class="key" data-key="o">O</button>
                    <button class="key" data-key="p">P</button>
                </div>
                <div class="keyboard-row">
                    <button class="key" data-key="a">A</button>
                    <button class="key" data-key="s">S</button>
                    <button class="key" data-key="d">D</button>
                    <button class="key" data-key="f">F</button>
                    <button class="key" data-key="g">G</button>
                    <button class="key" data-key="h">H</button>
                    <button class="key" data-key="j">J</button>
                    <button class="key" data-key="k">K</button>
                    <button class="key" data-key="l">L</button>
                </div>
                <div class="keyboard-row">
                    <button class="key" data-key=".">.</button>
                    <button class="key" data-key="z">Z</button>
                    <button class="key" data-key="x">X</button>
                    <button class="key" data-key="c">C</button>
                    <button class="key" data-key="v">V</button>
                    <button class="key" data-key="b">B</button>
                    <button class="key" data-key="n">N</button>
                    <button class="key" data-key="m">M</button>
                    <button class="key" data-key=",">,</button>
                </div>
                <div class="keyboard-row" id="spacebarRow" style="display:none;">
                    <button class="key key-space" data-key=" ">SPACE</button>
                </div>
            </div>
        </div>
        
        <!-- Number keyboard for math mode -->
        <div id="numberKeyboard">
            <div class="keyboard-row">
                <button class="key" data-key="1">1</button>
                <button class="key" data-key="2">2</button>
                <button class="key" data-key="3">3</button>
                <button class="key" data-key="4">4</button>
                <button class="key" data-key="5">5</button>
            </div>
            <div class="keyboard-row">
                <button class="key" data-key="6">6</button>
                <button class="key" data-key="7">7</button>
                <button class="key" data-key="8">8</button>
                <button class="key" data-key="9">9</button>
                <button class="key" data-key="0">0</button>
            </div>
        </div>
    </div>

    <!-- Time Selection Screen (outside gameContainer) -->
    <div id="timeSelection">
        <canvas id="menuStarCanvas"></canvas>
        
        <div id="startScreenContent">
            <div id="rocketIcon">ðŸš€</div>
            <h1 id="gameTitle">Word Shooter!</h1>
            <p id="gameSubtitle">Show your typing skills</p>
            
            <div id="difficultyOptions">
                <div class="difficulty-option" data-mode="words">
                    <div class="difficulty-text">
                        <div class="difficulty-name">Words</div>
                        <div class="difficulty-desc">Quick reflexes</div>
                    </div>
                    <span class="mode-emoji">ðŸ‘¾</span>
                </div>
                
                <div class="difficulty-option" data-mode="sentences">
                    <div class="difficulty-text">
                        <div class="difficulty-name">Sentences</div>
                        <div class="difficulty-desc">Rhythm flow</div>
                    </div>
                    <span class="mode-emoji">ðŸ›¸</span>
                </div>
                
                <div class="difficulty-option" data-mode="math">
                    <div class="difficulty-text">
                        <div class="difficulty-name">Math</div>
                        <div class="difficulty-desc">Mental agility</div>
                    </div>
                    <span class="mode-emoji">ðŸ‘½</span>
                </div>
                
                <div class="difficulty-option" data-mode="journey">
                    <div class="difficulty-text">
                        <div class="difficulty-name">Adventure</div>
                        <div class="difficulty-desc">Full mastery</div>
                    </div>
                    <span class="mode-emoji">ðŸª</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sentences Mode Fixed Overlay -->
    <div id="sentencesOverlay">
        <div id="sentencesBox">
            <div id="sentencesMeta">
                <span id="sentencesHint">Start typing...</span>
                <div id="sentencesTimer">30s</div>
            </div>
            <div id="sentencesDurationBar">
                <div id="sentencesDurationFill"></div>
            </div>
            <div id="sentencesText"></div>
        </div>
    </div>

    <!-- Game Over Screen (outside gameContainer) -->
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <div id="finalScore"></div>
        <button id="restartBtn">Restart Game</button>
    </div>

    <!-- Celebration Screen (Score 1000) -->
    <div id="celebrationScreen" style="display: none;">
        <div id="celebrationTopBar">
            <div class="celebration-title">Word Shooter!</div>
            <div class="celebration-buttons">
                <button id="celebrationShuffleBtn" class="celebration-top-btn" title="Shuffle test data" style="display:none;">
                    <span class="material-symbols-outlined">shuffle</span>
                </button>
                <button id="celebrationTopRestartBtn" class="celebration-top-btn" title="Restart">
                    <span class="material-symbols-outlined">refresh</span>
                </button>
                <button id="celebrationTopHomeBtn" class="celebration-top-btn" title="Home">
                    <span class="material-symbols-outlined">home</span>
                </button>
                <button id="celebrationTopShareBtn" class="celebration-top-btn" title="Share">
                    <span class="material-symbols-outlined">share</span>
                </button>
            </div>
        </div>
        <div class="hover-3d-wrapper">
            <div class="hover-3d" id="celebrationCardWrapper">
                <div id="celebrationCard">
                    <div id="celebrationHeader">
                        <div class="header-left">
                            <div class="header-label">Score</div>
                            <div class="header-rank" id="playerRank">PRO</div>
                        </div>
                        <div class="header-value" id="celebrationScoreValue">0</div>
                    </div>
                    
                    <div id="celebrationBody">
                        <div class="left-stats">
                            <div class="stat-item">
                                <div class="stat-label" id="celebrationWpmLabel">WPM</div>
                                <div class="stat-value" id="celebrationWpm">0</div>
                            </div>
                            
                            <div class="stat-item">
                                <div class="stat-label" id="celebrationAccuracyLabel">ACCURACY</div>
                                <div class="stat-value" id="celebrationAccuracy">0%</div>
                            </div>
                        </div>
                        
                        <div id="celebrationRocketIcon">ðŸš€</div>
                        
                        <div class="bottom-stats">
                            <div class="bottom-stats-left">
                                <div class="bottom-stat-label" id="celebrationIncorrectLabel">Incorrect attempts</div>
                                <div class="bottom-stat-label">Missed</div>
                            </div>
                            <div class="bottom-stats-right">
                                <div class="bottom-stat-value" id="celebrationIncorrect">0</div>
                                <div class="bottom-stat-value" id="celebrationMissed">0</div>
                            </div>
                        </div>
                        
                        <!-- Journey mode 4-tab stats (shown only for journey) -->
                        <div id="journeyTabs">
                            <div class="journey-tab-nav">
                                <button class="journey-tab-btn active" data-tab="words">Word</button>
                                <button class="journey-tab-btn" data-tab="sentences">Sentence</button>
                                <button class="journey-tab-btn" data-tab="math">Math</button>
                                <button class="journey-tab-btn" data-tab="letters">Letter</button>
                            </div>
                            <!-- Words tab -->
                            <div class="journey-tab-content active" id="jtab-words">
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Completed</div>
                                    <div class="journey-stat-value" id="jw-hit">0</div>
                                </div>
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Missed</div>
                                    <div class="journey-stat-value" id="jw-missed">0</div>
                                </div>
                                <div class="journey-stat-block full-width">
                                    <div class="journey-stat-label">Incorrect attempts</div>
                                    <div class="journey-stat-value" id="jw-wrong">0</div>
                                </div>
                            </div>
                            <!-- Sentences tab -->
                            <div class="journey-tab-content" id="jtab-sentences">
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Completed</div>
                                    <div class="journey-stat-value" id="js-done">0</div>
                                </div>
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Missed</div>
                                    <div class="journey-stat-value" id="js-skipped">0</div>
                                </div>
                                <div class="journey-stat-block full-width">
                                    <div class="journey-stat-label">Word per minute</div>
                                    <div class="journey-stat-value" id="js-wrong">0</div>
                                </div>
                            </div>
                            <!-- Math tab -->
                            <div class="journey-tab-content" id="jtab-math">
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Completed</div>
                                    <div class="journey-stat-value" id="jm-solved">0</div>
                                </div>
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Missed</div>
                                    <div class="journey-stat-value" id="jm-missed">0</div>
                                </div>
                                <div class="journey-stat-block full-width">
                                    <div class="journey-stat-label">Solved under 1s</div>
                                    <div class="journey-stat-value" id="jm-fast">0</div>
                                </div>
                            </div>
                            <!-- Letter tab -->
                            <div class="journey-tab-content" id="jtab-letters">
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Completed</div>
                                    <div class="journey-stat-value" id="jl-hit">0</div>
                                </div>
                                <div class="journey-stat-block">
                                    <div class="journey-stat-label">Missed</div>
                                    <div class="journey-stat-value" id="jl-missed">0</div>
                                </div>
                                <div class="journey-stat-block full-width">
                                    <div class="journey-stat-label">Letter per second</div>
                                    <div class="journey-stat-value" id="jl-lps">0</div>
                                </div>
                            </div>
                        </div>

                        <div class="graph-container">
                            <div id="graphViewToggle">
                                <button id="btnViewToggle" onclick="toggleGraphView()">Click me</button>
                            </div>
                            <div id="graphView" style="margin-top:6px;">
                                <canvas id="performanceGraph" width="520" height="300"></canvas>
                                <div class="graph-labels">
                                    <div class="graph-time-label start" id="graphStartTime">0:00</div>
                                    <div class="graph-time-label center" id="graphCenterTime">(15 min)</div>
                                    <div class="graph-time-label end" id="graphEndTime">0:15</div>
                                </div>
                                <div id="graphLegend" style="font-size:8px; font-family:'Press Start 2P',cursive; text-align:center; margin-top:6px; color:rgba(255,255,255,0.5);">
                                    <span style="color:#FFD400">â–  WPM</span> &nbsp; <span style="color:#10b981">â–  Accuracy</span>
                                </div>
                            </div>
                            <div id="speedoView" style="display:none; margin-top:6px;">
                                <canvas id="speedometerCanvas" width="520" height="300"></canvas>
                            </div>
                        </div>
                        <div id="scoreboardLink">
                            <span id="playAgainLink">Play Again</span>
                        </div>
                    </div>
                </div>
                <!-- 8 empty divs needed for the 3D effect -->
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
        </div>
    </div>

    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseContent">
            <div id="pauseMicrocopy"></div>
            <div id="pauseIcon">
                <span class="material-symbols-outlined">play_arrow</span>
                <span class="pause-text">Continue</span>
            </div>
        </div>
    </div>

    <!-- Challenge Screen -->
    <div id="challengeScreen">
        <div id="challengeContent">
            <div id="challengeTimer">20 Sec</div>
            <h2 id="challengeTitle">SPEED ROUND</h2>
            <div id="challengeSentence"></div>
            <div id="challengeInput"></div>
        </div>
        
        <!-- On-screen keyboard for mobile/tablet -->
        <div id="challengeKeyboard">
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="q">Q</div>
                <div class="challenge-key" data-key="w">W</div>
                <div class="challenge-key" data-key="e">E</div>
                <div class="challenge-key" data-key="r">R</div>
                <div class="challenge-key" data-key="t">T</div>
                <div class="challenge-key" data-key="y">Y</div>
                <div class="challenge-key" data-key="u">U</div>
                <div class="challenge-key" data-key="i">I</div>
                <div class="challenge-key" data-key="o">O</div>
                <div class="challenge-key" data-key="p">P</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="a">A</div>
                <div class="challenge-key" data-key="s">S</div>
                <div class="challenge-key" data-key="d">D</div>
                <div class="challenge-key" data-key="f">F</div>
                <div class="challenge-key" data-key="g">G</div>
                <div class="challenge-key" data-key="h">H</div>
                <div class="challenge-key" data-key="j">J</div>
                <div class="challenge-key" data-key="k">K</div>
                <div class="challenge-key" data-key="l">L</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="z">Z</div>
                <div class="challenge-key" data-key="x">X</div>
                <div class="challenge-key" data-key="c">C</div>
                <div class="challenge-key" data-key="v">V</div>
                <div class="challenge-key" data-key="b">B</div>
                <div class="challenge-key" data-key="n">N</div>
                <div class="challenge-key" data-key="m">M</div>
                <div class="challenge-key" data-key="backspace">âŒ«</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key spacebar" data-key=" ">Space</div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        // sessionId: incremented each time a new game starts.
        // Every async callback captures the id at creation time and bails if it no longer matches.
        let _sessionId = 0;

        const game = {
            score: 0,
            highestScore: 0,
            currentInput: '',
            invaders: [],
            bullets: [],
            targetInvader: null,
            isGameOver: false,
            isPaused: false,
            mode: 'words', // 'words', 'sentences', 'math', 'journey'
            journeyPhase: 1, // For journey mode: 1=words, 2=sentences, 3=math, 4=fast words+letters, 5=chaos
            _phaseTransitioning: false,
            lastSpawn: 0,
            spawnInterval: 2500,
            invaderSpeed: 0.3,
            maxInvaders: 3,
            isChallenge: false,
            challengeTimer: null,
            challengeTimeLeft: 20,
            completedChallenges: [],
            isMathMode: false,
            currentMathQuestion: null,
            isLetterMode: false,
            celebrationShown: false,
            // Combo system
            consecutiveHits: 0,
            comboMultiplier: 1,
            // Stats tracking for celebration
            startTime: null,
            totalCharactersTyped: 0,
            correctCharacters: 0,
            incorrectAttempts: 0,
            missedWords: 0,
            consecutiveMisses: 0,
            fastestWordTime: null,
            wordStartTime: null,
            // Performance history for graph (track WPM and accuracy over time)
            wpmHistory: [],
            accuracyHistory: [],
            lastPerformanceCheck: null,
            lastSpeedIncrease: 0, // Track last score when speed was increased
            // Math mode specific tracking
            mathQuestionsAnswered: 0,
            totalMathSolveTime: 0,
            mathQuestionStartTime: null,
            spmHistory: [],         // SPM samples over time for graph
            solveTimeHistory: [],   // Avg solve time samples over time for graph
            // Sentences mode specific
            isSentenceActive: false,
            sentenceTimer: null,
            sentenceTimeLeft: 30,
            currentSentenceIndex: 0,
            usedSentences: [],
            consecutiveSentenceFailures: 0,
            // Journey per-phase stats
            journeyStats: {
                words:     { wordsHit: 0, wordsMissed: 0, incorrectKeys: 0, correctChars: 0 },
                sentences: { completed: 0, skipped: 0, incorrectKeys: 0, correctChars: 0 },
                math:      { solved: 0, missed: 0, fastSolves: 0, totalSolveTime: 0 },
                letters:   { hit: 0, missed: 0 }
            }
        };

        // Sentences for sentence mode (40-60 characters)
        const sentences = [
            "The quick brown fox jumps over the lazy dog.",
            "Pack my box with five dozen liquor jugs today.",
            "How vexingly quick daft zebras jump in the fog.",
            "The five boxing wizards jump quickly at dawn.",
            "Sphinx of black quartz, judge my solemn vow.",
            "Two driven jocks help fax my big quiz paper.",
            "Five quacking zephyrs jolt my wax bed badly.",
            "The jay, pig, fox, zebra and my wolves quack.",
            "Crazy Fredrick bought many very exquisite jewels.",
            "We promptly judged antique ivory buckles for prizes.",
            "A wizard job is to vex chumps quickly in fog.",
            "Watch Jeopardy, Alex Trebek hosted fun TV quiz games.",
            "Public buildings facing hazards jeopardize workers.",
            "Few black taxis drive up major roads on quiet nights.",
            "The job requires extra pluck and zeal from every worker."
        ];
        
        const challengeMilestones = [200, 300, 400, 500, 600, 700];

        // Letters for letter mode
        const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');

        // Helper function to get current mode based on journey phase
        function getJourneyPhaseMode() {
            if (game.mode !== 'journey') return game.mode;
            const s = game.score;
            if (s >= 900) return 'math';      // Phase 8: math 3x   (900-1000)
            if (s >= 800) return 'words';     // Phase 7: letters 3x (800-899, isLetterMode flag)
            if (s >= 500) return 'sentences'; // Phase 6: sentences 12s (500-799)
            if (s >= 400) return 'words';     // Phase 5: words 3x  (400-499)
            if (s >= 300) return 'math';      // Phase 4: math 2x   (300-399)
            if (s >= 200) return 'words';     // Phase 3: letters 2x (200-299, isLetterMode flag)
            if (s >= 100) return 'sentences'; // Phase 2: sentences 18s (100-199)
            return 'words';                   // Phase 1: words 2x  (0-99)
        }

        // Get journey phase number from score
        function getJourneyPhaseNumber() {
            const s = game.score;
            if (s >= 900) return 8;
            if (s >= 800) return 7;
            if (s >= 500) return 6;
            if (s >= 400) return 5;
            if (s >= 300) return 4;
            if (s >= 200) return 3;
            if (s >= 100) return 2;
            return 1;
        }
        
        // Check and trigger journey phase transitions
        function checkJourneyPhaseTransition() {
            if (game.mode !== 'journey') return;
            if (game._phaseTransitioning) return;

            const newPhase = getJourneyPhaseNumber();
            const oldPhase = game.journeyPhase;

            if (newPhase !== oldPhase) {
                game.journeyPhase = newPhase;
                const newMode = getJourneyPhaseMode();

                // Set speed multiplier for this phase
                const phaseSpeed = { 1:2, 2:1, 3:2, 4:2, 5:3, 6:1, 7:3, 8:3 };
                speedMultiplier = phaseSpeed[newPhase] || 1;
                speedDisplay.textContent = speedMultiplier + 'x';

                // Letter mode: phases 3 (200-299) and 7 (800-899)
                game.isLetterMode = (newPhase === 3 || newPhase === 7);

                // Math mode flag
                game.isMathMode = (newMode === 'math');

                const phaseNames = {
                    1: 'WORDS (2x)',
                    2: 'SENTENCES (18s)',
                    3: 'LETTERS (2x)',
                    4: 'MATH (2x)',
                    5: 'WORDS (3x)',
                    6: 'SENTENCES (12s)',
                    7: 'LETTERS (3x)',
                    8: 'MATH (3x)'
                };
                const phaseColors = {
                    2: '#4A90E2',
                    3: '#00D4FF',
                    4: '#E67E22',
                    5: '#FF4500',
                    6: '#4A90E2',
                    7: '#00D4FF',
                    8: '#E67E22'
                };

                // Score regression (dropped to lower phase) â€” switch mode silently, no overlay
                if (newPhase < oldPhase) {
                    game.isSentenceActive = false;
                    game.invaders.forEach(inv => { if (inv.element) inv.element.remove(); });
                    game.invaders = [];
                    game.isMathMode = (newMode === 'math');
                    game.isLetterMode = (newPhase === 3 || newPhase === 7);
                    // Update spacebar visibility on mobile
                    const isMobileSilent = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
                    if (isMobileSilent) {
                        const spacebarRow = document.getElementById('spacebarRow');
                        if (spacebarRow) spacebarRow.style.display = newMode === 'sentences' ? 'flex' : 'none';
                    }
                    return;
                }

                triggerPhaseTransition(newMode, newPhase, phaseNames[newPhase] || '', phaseColors[newPhase] || '#fff');
            }
        }
        
        // Visual transition between journey phases
        function triggerPhaseTransition(newMode, newPhase, phaseName, phaseColor) {
            if (game._phaseTransitioning) return;
            game._phaseTransitioning = true;
            game.isPaused = true;
            resetCombo();
            
            // Fade out all remaining invaders gracefully
            game.invaders.forEach(inv => {
                if (inv.element) {
                    inv.element.style.transition = 'opacity 0.4s ease-out';
                    inv.element.style.opacity = '0';
                    setTimeout(() => { try { inv.element.remove(); } catch(e){} }, 420);
                }
            });
            game.invaders = [];
            game.isSentenceActive = false;
            
            // Reset mode flags based on new phase
            game.isMathMode = (newMode === 'math');
            game.isLetterMode = (newPhase === 3 || newPhase === 7); // Phases 3 (200â€“299) and 7 (800â€“899) = letters
            
            // Adjust invader speed for phase (base speed; speedMultiplier handles the rest)
            // Sentences phases use slower base so overlay feels right; words/letters/math use normal base
            if (newPhase === 2 || newPhase === 7) {
                game.invaderSpeed = 0.3; // sentences - invader speed irrelevant (overlay)
            } else {
                game.invaderSpeed = 0.3; // all non-sentence phases start at base speed
            }
            
            // Handle keyboard switching for math mode on mobile
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                const spacebarRow = document.getElementById('spacebarRow');

                if (newMode === 'math') {
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    normalKeyboard.style.display = '';
                    numberKeyboard.classList.remove('show');
                }

                // Show spacebar only during sentences phases (2 and 6 in journey)
                if (spacebarRow) {
                    spacebarRow.style.display = newMode === 'sentences' ? 'flex' : 'none';
                }
            }

            // Show fullscreen transition
            showPhaseTransitionScreen(phaseName || '', phaseColor || '#fff');
            
            // Resume after 2 seconds
            const _phaseSid = _sessionId;
            setTimeout(() => {
                if (_sessionId !== _phaseSid) return;
                game.isPaused = false;
                game._phaseTransitioning = false;
                hidePhaseTransitionScreen();
                // Kick off the correct spawner for the new phase
                if (newMode === 'sentences') {
                    spawnSentence();
                } else if (newMode === 'math') {
                    spawnMathInvader();
                }
                // words/letters: game loop handles spawning automatically
            }, 2000);
        }
        
        // Show phase transition overlay
        function showPhaseTransitionScreen(phaseName, accentColor) {
            let overlay = document.getElementById('phaseTransitionOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'phaseTransitionOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 5000;
                    font-family: 'Press Start 2P', cursive;
                    font-size: 32px;
                    color: white;
                    text-align: center;
                    padding: 20px;
                    transition: opacity 0.3s;
                `;
                document.body.appendChild(overlay);
            }
            
            overlay.style.background = 'radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%)';
            overlay.style.opacity = '0';
            overlay.style.display = 'flex';
            overlay.innerHTML = `
                <div style="
                    background: rgba(26, 41, 66, 0.85);
                    border: 2px solid ${accentColor};
                    border-radius: 16px;
                    padding: 30px 48px;
                    box-shadow: 0 0 40px ${accentColor}44, 0 8px 32px rgba(0,0,0,0.5);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 12px;
                ">
                    <div style="font-size: 13px; color: rgba(255,255,255,0.5); letter-spacing: 2px;">NEXT PHASE</div>
                    <div style="font-size: 28px; color: ${accentColor}; text-shadow: 0 0 20px ${accentColor}88;">${phaseName}</div>
                </div>
            `;
            
            // Fade in
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 10);
        }
        
        function hidePhaseTransitionScreen() {
            const overlay = document.getElementById('phaseTransitionOverlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 300);
            }
        }

        // Math mode functions
        function generateMathQuestion() {
            const operations = ['+', '-', '*'];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            
            let num1, num2, answer, displayOperation;
            
            switch(operation) {
                case '+':
                    num1 = Math.floor(Math.random() * 50) + 1;
                    num2 = Math.floor(Math.random() * 50) + 1;
                    answer = num1 + num2;
                    displayOperation = '+';
                    break;
                case '-':
                    num1 = Math.floor(Math.random() * 50) + 20;
                    num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
                    answer = num1 - num2;
                    displayOperation = '-';
                    break;
                case '*':
                    num1 = Math.floor(Math.random() * 12) + 1;
                    num2 = Math.floor(Math.random() * 12) + 1;
                    answer = num1 * num2;
                    displayOperation = 'x';  // Use 'x' instead of '*' for display
                    break;
            }
            
            return {
                question: `${num1}${displayOperation}${num2}`,
                answer: answer.toString()
            };
        }

        // Word list for invaders - diverse vocabulary to avoid repetition
        // Categorized word lists - ALL REAL WORDS
        const wordCategories = {
            all: [
                // Common animals
                'dog', 'cat', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'deer',
                'rabbit', 'mouse', 'rat', 'snake', 'frog', 'fish', 'bird', 'eagle',
                'hawk', 'owl', 'crow', 'duck', 'goose', 'swan', 'horse', 'cow',
                'pig', 'sheep', 'goat', 'chicken', 'turkey', 'elephant', 'rhino', 'hippo',
                
                // Common plants
                'rose', 'tulip', 'daisy', 'lily', 'orchid', 'violet', 'jasmine', 'sunflower',
                'oak', 'pine', 'maple', 'birch', 'willow', 'palm', 'bamboo', 'cactus',
                'fern', 'moss', 'ivy', 'grass', 'wheat', 'rice', 'corn', 'tomato',
                'potato', 'carrot', 'lettuce', 'spinach', 'basil', 'mint', 'sage', 'thyme',
                
                // Common science words
                'atom', 'cell', 'gene', 'solar', 'lunar', 'planet', 'orbit', 'energy',
                'force', 'gravity', 'matter', 'quantum', 'carbon', 'oxygen', 'nitrogen', 'hydrogen',
                'electron', 'proton', 'neutron', 'molecule', 'protein', 'enzyme', 'virus', 'bacteria',
                'plasma', 'crystal', 'magma', 'lava', 'fossil', 'mineral', 'climate', 'ocean',
                
                // Common Gen Z words
                'slay', 'vibe', 'fire', 'lit', 'cap', 'bet', 'flex', 'goat',
                'yeet', 'mood', 'fam', 'bruh', 'bussin', 'drip', 'sus', 'valid',
                'cringe', 'toxic', 'savage', 'extra', 'basic', 'salty', 'vibes', 'energy',
                'squad', 'goals', 'icon', 'legend', 'queen', 'king', 'epic', 'dope',
                
                // General words
                'house', 'tree', 'water', 'fire', 'earth', 'wind', 'stone', 'metal',
                'wood', 'glass', 'paper', 'book', 'pen', 'desk', 'chair', 'table',
                'door', 'window', 'wall', 'floor', 'roof', 'garden', 'park', 'road',
                'bridge', 'river', 'lake', 'ocean', 'mountain', 'valley', 'forest', 'field',
                'cloud', 'rain', 'snow', 'sun', 'moon', 'star', 'night', 'day',
                'morning', 'evening', 'spring', 'summer', 'autumn', 'winter', 'season', 'year'
            ],
            
            animals: [
                'dog', 'cat', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'deer',
                'rabbit', 'mouse', 'rat', 'hamster', 'guinea', 'squirrel', 'beaver', 'otter',
                'snake', 'lizard', 'turtle', 'frog', 'toad', 'newt', 'salamander', 'gecko',
                'fish', 'shark', 'whale', 'dolphin', 'seal', 'walrus', 'octopus', 'squid',
                'bird', 'eagle', 'hawk', 'falcon', 'owl', 'crow', 'raven', 'parrot',
                'duck', 'goose', 'swan', 'penguin', 'ostrich', 'emu', 'peacock', 'heron',
                'horse', 'donkey', 'zebra', 'cow', 'bull', 'buffalo', 'bison', 'ox',
                'pig', 'boar', 'sheep', 'ram', 'goat', 'llama', 'alpaca', 'camel',
                'chicken', 'rooster', 'turkey', 'pheasant', 'quail', 'pigeon', 'dove', 'sparrow',
                'elephant', 'rhino', 'hippo', 'giraffe', 'zebra', 'antelope', 'gazelle', 'impala',
                'monkey', 'ape', 'gorilla', 'chimp', 'lemur', 'baboon', 'gibbon', 'orangutan',
                'kangaroo', 'koala', 'wombat', 'wallaby', 'platypus', 'echidna', 'possum', 'bandicoot',
                'bee', 'wasp', 'ant', 'beetle', 'butterfly', 'moth', 'fly', 'mosquito',
                'spider', 'scorpion', 'mantis', 'cricket', 'grasshopper', 'dragonfly', 'ladybug', 'firefly'
            ],
            
            plants: [
                'rose', 'tulip', 'daisy', 'lily', 'orchid', 'violet', 'jasmine', 'sunflower',
                'poppy', 'peony', 'iris', 'carnation', 'marigold', 'zinnia', 'petunia', 'begonia',
                'oak', 'pine', 'maple', 'birch', 'willow', 'elm', 'ash', 'beech',
                'palm', 'cedar', 'spruce', 'fir', 'cypress', 'redwood', 'sequoia', 'mahogany',
                'bamboo', 'cactus', 'succulent', 'aloe', 'agave', 'yucca', 'jade', 'ficus',
                'fern', 'moss', 'lichen', 'algae', 'seaweed', 'kelp', 'ivy', 'vine',
                'grass', 'wheat', 'rice', 'corn', 'barley', 'oats', 'rye', 'millet',
                'tomato', 'potato', 'carrot', 'onion', 'garlic', 'pepper', 'cucumber', 'lettuce',
                'spinach', 'cabbage', 'broccoli', 'cauliflower', 'celery', 'radish', 'turnip', 'beet',
                'basil', 'mint', 'sage', 'thyme', 'oregano', 'parsley', 'cilantro', 'dill',
                'lavender', 'rosemary', 'chamomile', 'hibiscus', 'lotus', 'azalea', 'camellia', 'magnolia',
                'apple', 'orange', 'banana', 'grape', 'cherry', 'peach', 'pear', 'plum',
                'mango', 'papaya', 'coconut', 'pineapple', 'melon', 'berry', 'lemon', 'lime'
            ],
            
            science: [
                // Physics & Chemistry
                'atom', 'molecule', 'electron', 'proton', 'neutron', 'photon', 'quark', 'ion',
                'plasma', 'nucleus', 'isotope', 'catalyst', 'enzyme', 'polymer', 'crystal', 'alloy',
                'quantum', 'particle', 'matter', 'energy', 'entropy', 'velocity', 'momentum', 'friction',
                'gravity', 'radiation', 'magnetic', 'electric', 'thermal', 'kinetic', 'potential', 'force',
                
                // Biology & Medicine
                'cell', 'tissue', 'organ', 'genome', 'gene', 'protein', 'amino', 'lipid',
                'membrane', 'mitosis', 'meiosis', 'nucleus', 'ribosome', 'organelle', 'cytoplasm', 'chloroplast',
                'bacteria', 'virus', 'pathogen', 'antibody', 'antigen', 'immune', 'vaccine', 'syndrome',
                'neuron', 'synapse', 'hormone', 'insulin', 'cortisol', 'dopamine', 'serotonin', 'adrenaline',
                
                // Earth & Space Sciences
                'asteroid', 'comet', 'nebula', 'galaxy', 'planet', 'orbit', 'eclipse', 'cosmos',
                'meteor', 'crater', 'lunar', 'solar', 'stellar', 'cosmic', 'quasar', 'pulsar',
                'geology', 'mineral', 'crystal', 'fossil', 'sediment', 'magma', 'lava', 'tectonic',
                'seismic', 'volcano', 'erosion', 'glacier', 'ocean', 'climate', 'ozone', 'carbon',
                
                // Advanced Scientific Terms
                'algorithm', 'quantum', 'spectrum', 'frequency', 'wavelength', 'amplitude', 'resonance', 'diffraction',
                'osmosis', 'diffusion', 'synthesis', 'analysis', 'hypothesis', 'theory', 'axiom', 'theorem',
                'vector', 'matrix', 'exponential', 'logarithm', 'calculus', 'topology', 'entropy', 'equilibrium'
            ],
            
            genz: [
                // Gen Z slang and expressions
                'slay', 'vibe', 'fire', 'lit', 'cap', 'bet', 'flex', 'goat',
                'yeet', 'stan', 'simp', 'mood', 'fam', 'bruh', 'lowkey', 'highkey',
                'bussin', 'sheesh', 'drip', 'sus', 'valid', 'rent', 'snatched', 'slaps',
                'hits', 'ghosts', 'cringe', 'toxic', 'savage', 'extra', 'basic', 'salty',
                'shook', 'woke', 'clout', 'hype', 'ghost', 'finsta', 'main', 'spam',
                'tea', 'shade', 'glow', 'snack', 'ship', 'squad', 'goals', 'vibes',
                'energy', 'aura', 'serves', 'period', 'icon', 'legend', 'queen', 'king',
                'bop', 'slap', 'banger', 'tracks', 'tunes', 'jams', 'beats', 'bars',
                'fire', 'flames', 'heat', 'hot', 'cold', 'fresh', 'clean', 'smooth',
                'crisp', 'sharp', 'tight', 'solid', 'dope', 'sick', 'ill', 'wicked',
                'crazy', 'insane', 'mental', 'wild', 'epic', 'mega', 'ultra', 'super',
                'hyper', 'turbo', 'nitro', 'blast', 'boom', 'pow', 'bang', 'blast'
            ]
        };
        
        // Current game state
        let currentCategory = 'all';
        let words = wordCategories.all;


        // DOM elements
        const gunElement = document.getElementById('gun');
        const inputDisplay = document.getElementById('inputDisplay');
        const mobileInput = document.getElementById('mobileInput');
        const topSide = document.getElementById('topSide');
        const scoreElement = document.getElementById('score');
        const scoreValue = document.getElementById('scoreValue');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const categoryDisplay = null; // removed from UI
        const pauseBtn = document.getElementById('pauseBtn');
        const restartGameBtn = document.getElementById('restartGameBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const gameContainer = document.getElementById('gameContainer');
        const timeSelection = document.getElementById('timeSelection');
        const topbar = document.getElementById('topbar');

        (function initStarfield() {
            // Shared star data factory
            function makeStars() {
                const LAYERS = [
                    { count: 120, speed: 0.18, minR: 0.3, maxR: 0.8,  alpha: 0.45 },
                    { count: 60,  speed: 0.55, minR: 0.6, maxR: 1.3,  alpha: 0.65 },
                    { count: 28,  speed: 1.4,  minR: 1.0, maxR: 2.2,  alpha: 0.85 },
                ];
                const NEBULAE = Array.from({ length: 5 }, () => ({
                    x: Math.random() * 100,
                    y: Math.random() * 100,
                    r: 40 + Math.random() * 80,
                    hue: [200, 230, 260, 180][Math.floor(Math.random() * 4)],
                    alpha: 0.018 + Math.random() * 0.022,
                }));
                const stars = LAYERS.flatMap(layer =>
                    Array.from({ length: layer.count }, () => ({
                        x: Math.random(),
                        y: Math.random(),
                        r: layer.minR + Math.random() * (layer.maxR - layer.minR),
                        speed: layer.speed * (0.7 + Math.random() * 0.6),
                        alpha: layer.alpha * (0.6 + Math.random() * 0.4),
                        twinkle: Math.random() * Math.PI * 2,
                        twinkleSpeed: 0.01 + Math.random() * 0.025,
                        trail: layer.speed > 1 ? (0.012 + Math.random() * 0.018) : 0,
                    }))
                );
                return { stars, NEBULAE };
            }

            function initCanvas(canvas, getSpeedScale) {
                const ctx = canvas.getContext('2d');
                let W, H;
                function resize() {
                    W = canvas.width  = canvas.offsetWidth;
                    H = canvas.height = canvas.offsetHeight;
                }
                resize();
                window.addEventListener('resize', resize);

                const { stars, NEBULAE } = makeStars();

                function draw() {
                    ctx.clearRect(0, 0, W, H);

                    NEBULAE.forEach(n => {
                        const gx = n.x / 100 * W;
                        const gy = n.y / 100 * H;
                        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, n.r);
                        g.addColorStop(0, `hsla(${n.hue},70%,60%,${n.alpha})`);
                        g.addColorStop(1, 'transparent');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(gx, gy, n.r, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    const speedScale = getSpeedScale();

                    stars.forEach(s => {
                        s.y += s.speed * speedScale / H * 60;
                        if (s.y > 1) { s.y = 0; s.x = Math.random(); }

                        s.twinkle += s.twinkleSpeed;
                        const twinkleAlpha = s.alpha * (0.75 + 0.25 * Math.sin(s.twinkle));

                        const sx = s.x * W;
                        const sy = s.y * H;

                        if (s.trail > 0) {
                            const trailLen = s.trail * H;
                            const grad = ctx.createLinearGradient(sx, sy - trailLen, sx, sy);
                            grad.addColorStop(0, 'transparent');
                            grad.addColorStop(1, `rgba(200,220,255,${twinkleAlpha * 0.6})`);
                            ctx.strokeStyle = grad;
                            ctx.lineWidth = s.r * 0.8;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy - trailLen);
                            ctx.lineTo(sx, sy);
                            ctx.stroke();
                        }

                        ctx.beginPath();
                        ctx.arc(sx, sy, s.r, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(210,228,255,${twinkleAlpha})`;
                        ctx.fill();
                    });

                    requestAnimationFrame(draw);
                }
                requestAnimationFrame(draw);
            }

            // Game screen canvas â€” speed follows score
            const gameCanvas = document.getElementById('starCanvas');
            if (gameCanvas) {
                initCanvas(gameCanvas, () => {
                    const score = (typeof game !== 'undefined') ? (game.score || 0) : 0;
                    return 0.008 + 0.292 * Math.pow(Math.min(score, 1000) / 1000, 2.2);
                });
            }

            // Menu/main page canvas â€” always barely visible (fixed 0.008)
            const menuCanvas = document.getElementById('menuStarCanvas');
            if (menuCanvas) {
                initCanvas(menuCanvas, () => 0.008);
            }
        })();

        // Invader class
        class Invader {
            constructor() {
                // Determine what type of invader to spawn based on mode and journey phase
                const currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
                
                if (currentMode === 'sentences') {
                    // Sentences are handled via fixed overlay, not moving invaders
                    this.word = '';
                    this.isSentence = true;
                    this.isNumber = false;
                    this.isUfo = false;
                    this.x = -9999;
                    this.y = -9999;
                    this.speedY = 0;
                    this.speedX = 0;
                    this.isDying = true;
                    this.element = null; // no DOM element
                    return;
                } else if (currentMode === 'math') {
                    // Math invader - math problem
                    const mathQuestion = generateMathQuestion();
                    this.word = mathQuestion.answer;
                    this.displayWord = mathQuestion.question;
                    this.emoji = 'ðŸ’¥';
                    this.isMathQuestion = true;
                    this.isNumber = false;
                    this.isSentence = false;
                    this.isUfo = false;
                    
                    const estimatedWidth = (mathQuestion.question.length * 15) + 40;
                    this.x = Math.max(0, (window.innerWidth / 2) - (estimatedWidth / 2));
                    this.y = 0;
                    this.speedY = game.invaderSpeed * (0.8 + Math.random() * 0.4) * speedMultiplier;
                    this.speedX = (Math.random() - 0.5) * 0.3;
                    this.element = this.createMathElement();
                    this.isDying = false;
                    return;
                } else if (game.isLetterMode) {
                    // Letter mode - single random aâ€“z letter with â­ emoji
                    this.word = letters[Math.floor(Math.random() * letters.length)];
                    this.emoji = 'â­';
                    this.isLetter = true;
                    this.isNumber = false;
                    this.isSentence = false;
                    this.isUfo = false;

                    const estimatedWidth = 60;
                    this.x = Math.random() * Math.max(100, window.innerWidth - estimatedWidth);
                    this.y = 0;
                    this.speedY = game.invaderSpeed * (0.8 + Math.random() * 0.4) * speedMultiplier;
                    this.speedX = (Math.random() - 0.5) * 0.3;
                    this.element = this.createElement();
                    this.isDying = false;
                } else {
                    // Words mode - single words with ðŸ‘¾
                    const usedWords = game.invaders
                        .filter(z => !z.isDying)
                        .map(z => z.word);
                    
                    let availableWords = words.filter(w => !usedWords.includes(w));
                    if (availableWords.length === 0) {
                        availableWords = words;
                    }
                    this.word = availableWords[Math.floor(Math.random() * availableWords.length)];
                    this.emoji = 'ðŸ‘¾';
                    this.isLetter = false;
                    this.isNumber = false;
                    this.isSentence = false;
                    this.isUfo = false;
                    
                    const estimatedWidth = (this.word.length * 15) + 40;
                    this.x = Math.random() * Math.max(100, window.innerWidth - estimatedWidth);
                    this.y = 0;
                    this.speedY = game.invaderSpeed * (0.8 + Math.random() * 0.4) * speedMultiplier;
                    this.speedX = (Math.random() - 0.5) * 0.3;
                    this.element = this.createElement();
                    this.isDying = false;
                }
            }

            createElement() {
                const invader = document.createElement('div');
                invader.className = 'invader';
                
                // Wrap each character in a span for progress effect
                const wordSpans = this.word.split('').map(char => `<span class="char">${char}</span>`).join('');
                
                // Add rotation class for letter invaders
                const emojiClass = this.isLetter ? 'invader-emoji letter-emoji' : 'invader-emoji';
                
                invader.innerHTML = `
                    <div class="invader-word">${wordSpans}</div>
                    <div class="${emojiClass}">${this.emoji}</div>
                `;
                invader.style.left = this.x + 'px';
                invader.style.top = this.y + 'px';
                gameContainer.appendChild(invader);
                this.wordElement = invader.querySelector('.invader-word');
                return invader;
            }

            createMathElement() {
                const invader = document.createElement('div');
                invader.className = 'invader';
                
                // Display the math question (e.g., "5 + 3")
                const displayText = this.displayWord || this.word;
                const wordSpans = displayText.split('').map(char => `<span class="char">${char}</span>`).join('');
                
                invader.innerHTML = `
                    <div class="invader-word">${wordSpans}</div>
                    <div class="invader-emoji">ðŸ‘½</div>
                `;
                invader.style.left = this.x + 'px';
                invader.style.top = this.y + 'px';
                gameContainer.appendChild(invader);
                this.wordElement = invader.querySelector('.invader-word');
                return invader;
            }

            update() {
                if (this.isDying) return;
                if (!this.element) { this.isDying = true; return; }

                this.y += this.speedY;
                this.x += this.speedX;

                // Get actual element width (word label can be wider than emoji)
                const elementWidth = this.element.offsetWidth || 100;
                
                // Bounce off left and right edges with proper boundary checking
                if (this.x < 0) {
                    this.x = 0;
                    this.speedX *= -1;
                } else if (this.x + elementWidth > window.innerWidth) {
                    this.x = window.innerWidth - elementWidth;
                    this.speedX *= -1;
                }

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                // Start fading when approaching the rocket area (70% down)
                const fadeStart = window.innerHeight * 0.65;
                const fadeEnd = window.innerHeight * 0.70;
                
                if (this.y >= fadeStart && this.y < fadeEnd) {
                    // Fade out as invader approaches the boundary
                    const fadeProgress = (this.y - fadeStart) / (fadeEnd - fadeStart);
                    const opacity = Math.max(0, 1 - fadeProgress);
                    this.element.style.opacity = opacity;
                }

                // Check if reached the rocket area (70% down the screen)
                if (this.y >= fadeEnd) {
                    this.reachedBottomSide();
                }
            }

            reachedBottomSide() {
                if (!this.isDying) {
                    game.missedWords++;
                    game.consecutiveMisses++;
                    resetCombo();

                    // Journey stat tracking
                    if (game.mode === 'journey') {
                        if (this.isMathQuestion) game.journeyStats.math.missed++;
                        else if (game.isLetterMode) game.journeyStats.letters.missed++;
                        else game.journeyStats.words.wordsMissed++;
                    }
                    
                    // In math mode, deduct 4 points and spawn new question
                    if (game.isMathMode && this.isMathQuestion) {
                        const penalty = 4;
                        const oldScore = game.score;
                        game.score = Math.max(0, game.score - penalty);
                        
                        // Animate score decrease
                        scoreValue.classList.remove('score-increase', 'score-decrease');
                        void scoreValue.offsetWidth; // Force reflow
                        scoreValue.classList.add('score-decrease');
                        
                        // Animate the counter from old value to new value (counting down)
                        animateValue(scoreValue, oldScore, game.score, 400);
                        
                        // Remove red color after animation
                        setTimeout(() => {
                            scoreValue.classList.remove('score-decrease');
                        }, 500);
                        
                        // Check if game over
                        if (game.score === 0 || game.consecutiveMisses >= 5) {
                            gameOver();
                            return;
                        }
                        
                        this.die();
                        // Spawn new math question after a short delay
                        setTimeout(() => {
                            spawnMathInvader();
                        }, 500);
                        return;
                    }
                    
                    // Normal mode - deduct score based on word length (1 point per character)
                    const penalty = this.word.length;
                    const oldScore = game.score;
                    game.score = Math.max(0, game.score - penalty);
                    
                    // Animate score decrease
                    scoreValue.classList.remove('score-increase', 'score-decrease');
                    void scoreValue.offsetWidth; // Force reflow
                    scoreValue.classList.add('score-decrease');
                    
                    // Animate the counter from old value to new value (counting down)
                    animateValue(scoreValue, oldScore, game.score, 400);
                    
                    // Remove red color after animation
                    setTimeout(() => {
                        scoreValue.classList.remove('score-decrease');
                    }, 500);
                    
                    // Check if game over
                    if (game.score === 0 || game.consecutiveMisses >= 3) {
                        gameOver();
                        return;
                    }
                    
                    this.die();
                }
            }

            die() {
                this.isDying = true;
                if (!this.element) return;
                this.element.classList.add('dying');
                setTimeout(() => {
                    this.element.remove();
                }, 500);
            }

            getCenter() {
                return {
                    x: this.x + 25,
                    y: this.y + 40
                };
            }
        }

        // Bullet class
        class Bullet {
            constructor(targetX, targetY) {
                // Get rocket position and calculate tip based on current rotation
                const gunRect = gunElement.getBoundingClientRect();
                const gunCenterX = gunRect.left + gunRect.width / 2;
                const gunCenterY = gunRect.top + gunRect.height / 2;
                
                // Get current rotation from transform
                const transform = window.getComputedStyle(gunElement).transform;
                let angle = -45; // default angle
                if (transform && transform !== 'none') {
                    const values = transform.split('(')[1].split(')')[0].split(',');
                    const a = parseFloat(values[0]);
                    const b = parseFloat(values[1]);
                    angle = Math.atan2(b, a) * (180 / Math.PI);
                }
                
                // Calculate tip offset - rocket emoji tip is roughly at the top-left when unrotated
                // We need to find where the tip is after rotation
                const tipDistance = 50; // distance from center to visual tip (increased from 40)
                const tipAngle = angle - 45; // The tip is 45 degrees counter-clockwise from the rocket's rotation
                const angleRad = tipAngle * Math.PI / 180;
                
                this.x = gunCenterX + tipDistance * Math.cos(angleRad);
                this.y = gunCenterY + tipDistance * Math.sin(angleRad);
                this.targetX = targetX;
                this.targetY = targetY;
                
                const distance = Math.sqrt(
                    Math.pow(targetX - this.x, 2) + 
                    Math.pow(targetY - this.y, 2)
                );
                
                const speed = 49.5; // Increased by 50% (was 33)
                this.speedX = (targetX - this.x) / distance * speed;
                this.speedY = (targetY - this.y) / distance * speed;
                
                this.element = this.createElement();
                this.distanceTraveled = 0;
                this.maxDistance = distance;
            }

            createElement() {
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                
                // Calculate angle for rotation
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const degrees = angle * (180 / Math.PI);
                
                // Fixed short beam length (like a bullet)
                const beamLength = 40; // Short laser bullet (was distance-based)
                
                // Offset by half the beam width (1.5px) to center it on the tip
                bullet.style.left = (this.x - 1.5) + 'px';
                bullet.style.top = this.y + 'px';
                bullet.style.height = beamLength + 'px';
                bullet.style.transform = `rotate(${degrees + 90}deg)`; // +90 because beam extends downward by default
                bullet.style.transformOrigin = 'top center';
                
                gameContainer.appendChild(bullet);
                return bullet;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.distanceTraveled += Math.sqrt(
                    this.speedX * this.speedX + 
                    this.speedY * this.speedY
                );

                // Calculate angle
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const degrees = angle * (180 / Math.PI);
                
                // Fixed short beam length (like a bullet) - stays constant
                const beamLength = 40;
                
                // Update position with center offset
                this.element.style.left = (this.x - 1.5) + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.height = beamLength + 'px';
                this.element.style.transform = `rotate(${degrees + 90}deg)`;

                return this.distanceTraveled < this.maxDistance + 50;
            }

            remove() {
                this.element.remove();
            }
        }

        // Spawn invader
        function spawnInvader() {
            if (game.isGameOver) return; // safety guard
            const currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            
            // Sentences mode - use fixed overlay, not moving invaders
            if (currentMode === 'sentences') {
                if (!game.isSentenceActive) {
                    spawnSentence();
                }
                return;
            }
            
            // In math mode, only spawn if no active invaders
            if (game.isMathMode) {
                const activeInvaders = game.invaders.filter(z => !z.isDying).length;
                if (activeInvaders === 0) {
                    spawnMathInvader();
                }
                return;
            }
            
            // Letter mode - higher frequency, more invaders allowed
            if (game.isLetterMode) {
                const activeInvaders = game.invaders.filter(z => !z.isDying).length;
                const maxLetterInvaders = 10; // Much higher than normal
                if (activeInvaders < maxLetterInvaders) {
                    const invader = new Invader();
                    game.invaders.push(invader);
                }
                return;
            }
            
            // Normal mode - spawn if under the max invader limit
            const activeInvaders = game.invaders.filter(z => !z.isDying).length;
            if (activeInvaders < game.maxInvaders) {
                const invader = new Invader();
                game.invaders.push(invader);
            }
        }

        function spawnMathInvader() {
            const mathQuestion = generateMathQuestion();
            game.currentMathQuestion = mathQuestion;
            game.mathQuestionStartTime = Date.now();
            
            // Create invader directly (Invader constructor in math mode already creates the element)
            const invader = new Invader();
            // Override word to be the answer (display is already the question from constructor)
            game.invaders.push(invader);
        }

        // Sentences mode - spawn a fixed sentence overlay
        function spawnSentence() {
            // Guard: only run if we're in a sentences-capable mode
            const _currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            if (_currentMode !== 'sentences') return;
            if (game.isSentenceActive) return;
            if (game.isGameOver) return;
            
            game.isSentenceActive = true;
            game.currentInput = '';
            // Also clear mobileInput so stale text doesn't dispatch phantom keypresses on mobile
            const _mobileInput = document.getElementById('mobileInput');
            if (_mobileInput) _mobileInput.value = '';
            
            // Pick a sentence (avoid recent repeats)
            let availableSentences = sentences.filter((_, i) => !game.usedSentences.includes(i));
            if (availableSentences.length === 0) {
                game.usedSentences = [];
                availableSentences = sentences;
            }
            const sentenceIndex = Math.floor(Math.random() * availableSentences.length);
            const sentenceText = availableSentences[sentenceIndex];
            const originalIndex = sentences.indexOf(sentenceText);
            game.usedSentences.push(originalIndex);
            game.currentSentenceText = sentenceText;
            
            // Calculate duration:
            // Journey: phase 2 = 18s, phase 7 = 12s; standalone sentences mode uses speed button setting
            let duration;
            if (game.mode === 'journey') {
                duration = game.journeyPhase === 6 ? 12 : 18; // Phase 6 (500â€“799) = 12s, Phase 2 (100â€“199) = 18s
            } else {
                // 1x = 24s, 2x = 18s, 3x = 12s
                duration = sentenceSpeedDurations[speedMultiplier] || 24;
            }
            game.sentenceTimeLeft = duration;
            
            const overlay = document.getElementById('sentencesOverlay');
            const box = document.getElementById('sentencesBox');
            const textEl = document.getElementById('sentencesText');
            const timerEl = document.getElementById('sentencesTimer');
            const fillEl = document.getElementById('sentencesDurationFill');
            
            // Render chars grouped by word to prevent mid-word line breaks
            const words = sentenceText.split(' ');
            textEl.innerHTML = words.map(word => 
                `<span class="word">${word.split('').map(char => `<span class="char">${char}</span>`).join('')}</span>`
            ).join('<span class="char space">&nbsp;</span>');
            
            timerEl.textContent = `${duration}s`;
            timerEl.style.color = 'rgba(255,255,255,0.5)';

            // Reset hint text
            const hintEl = document.getElementById('sentencesHint');
            if (hintEl) { hintEl.textContent = 'Start typing...'; }
            
            // Reset progress bar instantly (full width, no transition)
            fillEl.style.transition = 'none';
            fillEl.style.width = '100%';
            // Remove CSS-based transition shrink - bar will be updated by interval
            
            // Show overlay and trigger slide-in animation â€” reset ALL animation state first
            overlay.classList.add('show');
            box.classList.remove('animate-in', 'animate-out');
            // Force the browser to clear any animation forwards-fill by temporarily nulling animation
            box.style.animation = 'none';
            box.style.opacity = '';
            box.style.transform = '';
            void box.offsetWidth; // flush style, reset animation
            box.style.animation = '';
            box.classList.add('animate-in');
            
            // Start progress bar + countdown AFTER slide-in (400ms)
            const _spawnSession = _sessionId; // capture session at spawn time
            setTimeout(() => {
                // Bail if the session changed (mode switch, restart, etc.)
                if (_sessionId !== _spawnSession || !game.isSentenceActive) return;
                
                // Clear any leftover timer (safety guard)
                if (game.sentenceTimer) {
                    clearInterval(game.sentenceTimer);
                    game.sentenceTimer = null;
                }
                
                // Update both bar width and text every second in sync
                game.sentenceTimer = setInterval(() => {
                    // Bail if session changed or sentence was dismissed
                    if (_sessionId !== _spawnSession || !game.isSentenceActive) {
                        clearInterval(game.sentenceTimer);
                        game.sentenceTimer = null;
                        return;
                    }
                    if (game.isPaused) return;
                    game.sentenceTimeLeft--;
                    timerEl.textContent = `${Math.max(0, game.sentenceTimeLeft)}s`;
                    timerEl.style.color = game.sentenceTimeLeft <= 5 ? '#ff4757' : 'rgba(255,255,255,0.5)';
                    const pct = Math.max(0, (game.sentenceTimeLeft / duration) * 100);
                    fillEl.style.transition = 'width 1s linear';
                    fillEl.style.width = pct + '%';
                    if (game.sentenceTimeLeft <= 0) {
                        skipSentence();
                    }
                }, 1000);
            }, 400);
        }
        
        function updateSentenceProgress() {
            const textEl = document.getElementById('sentencesText');
            if (!textEl) return;
            const chars = textEl.querySelectorAll('.char');
            const input = game.currentInput;
            chars.forEach((char, index) => {
                char.classList.remove('correct', 'current');
                if (index < input.length) {
                    char.classList.add('correct');
                } else if (index === input.length) {
                    char.classList.add('current');
                }
            });
            // Update hint text on first keypress
            const hintEl = document.getElementById('sentencesHint');
            if (hintEl) {
                hintEl.textContent = input.length > 0 ? 'Keep Going...' : 'Start typing...';
            }
        }
        
        function dismissSentenceBox(callback) {
            const box     = document.getElementById('sentencesBox');
            const overlay = document.getElementById('sentencesOverlay');
            const sid     = _sessionId;
            box.classList.remove('animate-in');
            box.style.animation = 'none';
            box.style.opacity = '';
            box.style.transform = '';
            void box.offsetWidth;
            box.style.animation = '';
            box.classList.add('animate-out');
            setTimeout(() => {
                if (_sessionId !== sid) return;
                overlay.classList.remove('show');
                box.classList.remove('animate-out');
                // Mark sentence as no longer active right before the callback
                // (keeps it true during the dismiss animation to block race spawns)
                game.isSentenceActive = false;
                if (callback) callback();
            }, 360);
        }
        
        function completeSentence() {
            clearInterval(game.sentenceTimer);
            game.sentenceTimer = null;
            // Keep isSentenceActive = true during dismiss animation to prevent
            // the game loop's spawnInvader from racing in and double-spawning
            game.currentInput = '';
            playSuccessSound();
            if (game.mode === 'journey') game.journeyStats.sentences.completed++;
            
            // Award points â€” flat 20 pts, no time bonus
            const earnedPoints = 20;
            const oldScore = game.score;
            game.score += earnedPoints;
            if (game.score > game.highestScore) game.highestScore = game.score;
            
            // Combo update
            game.consecutiveHits++;
            updateComboMultiplier();
            game.consecutiveMisses = 0;
            game.consecutiveSentenceFailures = 0; // reset on success
            
            // Check journey phase transitions
            checkJourneyPhaseTransition();
            
            // Check for celebration
            if (game.score >= 1000 && !game.celebrationShown) {
                game.celebrationShown = true;
                dismissSentenceBox(() => showCelebration());
                return;
            }
            
            scoreValue.classList.remove('score-increase', 'score-decrease');
            void scoreValue.offsetWidth;
            scoreValue.classList.add('score-increase');
            animateValue(scoreValue, oldScore, game.score, 400);
            setTimeout(() => scoreValue.classList.remove('score-increase'), 500);
            
            // Slide out then spawn next â€” skip if phase transition just fired
            dismissSentenceBox(() => {
                if (!game.isGameOver && !game._phaseTransitioning) spawnSentence();
            });
        }
        
        function skipSentence() {
            clearInterval(game.sentenceTimer);
            game.sentenceTimer = null;
            // Keep isSentenceActive = true during dismiss animation (cleared in dismissSentenceBox)
            game.currentInput = '';
            game.missedWords++;
            resetCombo();
            if (game.mode === 'journey') game.journeyStats.sentences.skipped++;
            game.consecutiveSentenceFailures = (game.consecutiveSentenceFailures || 0) + 1;

            const penalty = 15;
            const oldScore = game.score;
            game.score = Math.max(0, game.score - penalty);
            
            scoreValue.classList.remove('score-increase', 'score-decrease');
            void scoreValue.offsetWidth;
            scoreValue.classList.add('score-decrease');
            animateValue(scoreValue, oldScore, game.score, 400);
            setTimeout(() => scoreValue.classList.remove('score-decrease'), 500);
            
            // Game over: score hit zero OR 2 consecutive sentence failures
            if (game.score === 0 || game.consecutiveSentenceFailures >= 2) {
                dismissSentenceBox(() => gameOver());
                return;
            }
            
            // Slide out then spawn next
            dismissSentenceBox(() => {
                if (!game.isGameOver) spawnSentence();
            });
        }

        // Shoot gun
        function shoot(invader) {
            gunElement.classList.add('shoot');
            setTimeout(() => gunElement.classList.remove('shoot'), 100);

            const center = invader.getCenter();
            const bullet = new Bullet(center.x, center.y);
            game.bullets.push(bullet);

            playShootSound();
            
            // Calculate and return travel time for the laser to reach target
            // Distance / speed, then convert frames to milliseconds (assuming 60fps)
            const travelTimeMs = (bullet.maxDistance / 49.5) * (1000 / 60);
            return travelTimeMs;
        }

        // Update score based on word length
        // Animated counter function
        function animateValue(element, start, end, duration) {
            const el = typeof element === 'string' ? document.getElementById(element) : element;
            if (!el) return;
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                const value = Math.floor(progress * (end - start) + start);
                el.textContent = value;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    el.textContent = end;
                }
            };
            window.requestAnimationFrame(step);
        }

        function updateScore(word, invader = null) {
            let basePoints = 0;
            const js = game.journeyStats;
            const inJourney = game.mode === 'journey';
            
            // Mode-based scoring + journey stat tracking
            if (invader && invader.isSentence) {
                basePoints = 20;
            } else if (invader && invader.isMathQuestion) {
                basePoints = 10;
                const fast = game.mathQuestionStartTime && (Date.now() - game.mathQuestionStartTime) < 1000;
                if (fast) basePoints += 1;
                if (inJourney) {
                    js.math.solved++;
                    if (fast) js.math.fastSolves++;
                    if (game.mathQuestionStartTime) js.math.totalSolveTime += Date.now() - game.mathQuestionStartTime;
                }
            } else if (invader && (invader.isLetter || invader.isNumber)) {
                basePoints = invader.isNumber ? 5 : word.length;
                if (inJourney) js.letters.hit++;
            } else {
                basePoints = word.length;
                if (inJourney) {
                    js.words.wordsHit++;
                    js.words.correctChars += word.length;
                }
            }
            
            // Apply combo multiplier
            const earnedPoints = Math.floor(basePoints * game.comboMultiplier);
            const oldScore = game.score;
            game.score += earnedPoints;
            
            // Increment consecutive hits for combo
            game.consecutiveHits++;
            updateComboMultiplier();
            
            // Reset consecutive misses
            game.consecutiveMisses = 0;
            
            // Check for journey phase transitions
            checkJourneyPhaseTransition();
            
            // Update highest score
            if (game.score > game.highestScore) {
                game.highestScore = game.score;
            }
            
            // Check for celebration at 1000
            if (game.score >= 1000 && !game.celebrationShown) {
                game.celebrationShown = true;
                setTimeout(() => {
                    showCelebration();
                }, 500);
            }
            
            // Animate score increase
            scoreValue.classList.remove('score-increase', 'score-decrease');
            void scoreValue.offsetWidth;
            scoreValue.classList.add('score-increase');
            animateValue(scoreValue, oldScore, game.score, 400);
            setTimeout(() => {
                scoreValue.classList.remove('score-increase');
            }, 500);
        }
        
        // Update combo multiplier based on consecutive hits
        function updateComboMultiplier() {
            if (game.consecutiveHits >= 10) {
                game.comboMultiplier = 3;
            } else if (game.consecutiveHits >= 5) {
                game.comboMultiplier = 2;
            } else if (game.consecutiveHits >= 3) {
                game.comboMultiplier = 1.5;
            } else {
                game.comboMultiplier = 1;
            }
            updateComboDisplay();
        }
        
        // Reset combo on miss or error
        function resetCombo() {
            game.consecutiveHits = 0;
            game.comboMultiplier = 1;
            updateComboDisplay();
        }
        
        // Update combo display in UI
        function updateComboDisplay() {
            let comboDisplay = document.getElementById('comboDisplay');
            if (!comboDisplay) {
                comboDisplay = document.createElement('div');
                comboDisplay.id = 'comboDisplay';
                comboDisplay.style.cssText = `
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Press Start 2P', cursive;
                    font-size: 16px;
                    color: #FFD700;
                    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    z-index: 1100;
                    display: none;
                    pointer-events: none;
                `;
                document.body.appendChild(comboDisplay);
            }
            
            if (game.consecutiveHits >= 3) {
                comboDisplay.textContent = `${game.consecutiveHits}x COMBO!`;
                comboDisplay.style.display = 'block';
                
                if (game.comboMultiplier >= 3) {
                    comboDisplay.style.color = '#FF4500';
                    comboDisplay.style.textShadow = '0 0 15px rgba(255, 69, 0, 0.7)';
                } else if (game.comboMultiplier >= 2) {
                    comboDisplay.style.color = '#FF8C00';
                    comboDisplay.style.textShadow = '0 0 12px rgba(255, 140, 0, 0.6)';
                } else {
                    comboDisplay.style.color = '#FFD700';
                    comboDisplay.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                }
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        // Show combo milestone messages
        function showComboMessage(message, color) {
            let messageDiv = document.getElementById('comboMessage');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'comboMessage';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-family: 'Press Start 2P', cursive;
                    font-size: 36px;
                    color: ${color};
                    text-shadow: 0 0 20px ${color};
                    z-index: 5500;
                    pointer-events: none;
                    opacity: 0;
                    transition: opacity 0.3s;
                `;
                document.body.appendChild(messageDiv);
            }
            
            messageDiv.textContent = message;
            messageDiv.style.color = color;
            messageDiv.style.textShadow = `0 0 20px ${color}`;
            messageDiv.style.opacity = '1';
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
            }, 1000);
        }
        
        // Screen shake effect
        function triggerScreenShake() {
            const container = document.getElementById('gameContainer');
            container.style.animation = 'shake 0.3s';
            setTimeout(() => {
                container.style.animation = '';
            }, 300);
        }

        // Check if score reached a challenge milestone (LEGACY - kept for compatibility)
        function checkChallengeMilestone() {
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            
            // Check for celebration at 1000
            if (game.score >= 1000 && !game.celebrationShown) {
                console.log('ðŸŽ‰ Score 1000 reached! Showing celebration...');
                game.celebrationShown = true;
                showCelebration();
                return;
            }
            
            // Check for letter mode at 900 (disable math mode first)
            if (game.score >= 900 && !game.isLetterMode) {
                game.isLetterMode = true;
                game.isMathMode = false;  // Disable math mode
                
                // Switch back to letter keyboard on mobile if it was number keyboard
                if (isMobile) {
                    document.getElementById('numberKeyboard').classList.remove('show');
                    document.getElementById('onScreenKeyboard').style.display = 'flex';
                }
                
                // Clear existing invaders
                game.invaders.forEach(inv => {
                    if (!inv.isDying) {
                        inv.element.remove();
                    }
                });
                game.invaders = [];
                return;
            }
            
            // Check for math mode at 800 (only if not yet in letter mode)
            if (game.score >= 800 && game.score < 900 && !game.isMathMode) {
                game.isMathMode = true;
                
                // Switch keyboards on mobile
                if (isMobile) {
                    document.getElementById('onScreenKeyboard').style.display = 'none';
                    document.getElementById('numberKeyboard').classList.add('show');
                }
                
                // Clear existing word invaders and spawn first math question
                game.invaders.forEach(inv => {
                    if (!inv.isDying) {
                        inv.element.remove();
                    }
                });
                game.invaders = [];
                spawnMathInvader();
                return;
            }
            
            // Check for challenge milestones
            for (let milestone of challengeMilestones) {
                if (game.score >= milestone && !game.completedChallenges.includes(milestone)) {
                    game.completedChallenges.push(milestone);
                    startChallenge();
                    break;
                }
            }
        }

        // Rotate rocket to face target
        function rotateRocketToTarget(targetInvader) {
            if (!targetInvader || targetInvader.isDying) {
                gunElement.style.transform = 'rotate(-45deg)'; // Default -45 degree angle (up-right)
                gunElement.classList.remove('aiming');
                return;
            }

            const center = targetInvader.getCenter();
            const shipX = window.innerWidth / 2;
            const shipY = window.innerHeight * 0.7 + 40; // Adjust to rocket tip

            const deltaX = center.x - shipX;
            
            // Determine if target is on left or right side
            // Rotate 30 degrees left (-75Â°) or right (-15Â°) from base -45Â°
            let angleDeg;
            if (deltaX < -100) {
                // Far left - rotate 30Â° left from -45Â° = -75Â°
                angleDeg = -75;
            } else if (deltaX > 100) {
                // Far right - rotate 30Â° right from -45Â° = -15Â°
                angleDeg = -15;
            } else {
                // Center - interpolate between -75Â° and -15Â°
                // Map deltaX from [-100, 100] to [-75, -15]
                const t = (deltaX + 100) / 200; // normalize to [0, 1]
                angleDeg = -75 + (t * 60); // -75 + (0 to 1) * 60 = -75 to -15
            }

            gunElement.classList.add('aiming');
            gunElement.style.transform = `rotate(${angleDeg}deg)`;
        }

        // â”€â”€ Ambient Space Music (CBL-style: downtempo atmospheric electronic) â”€â”€
        const ambientMusic = (() => {
            let ctx = null, masterGain = null, reverbNode = null;
            let started = false, muted = false;
            let nodes = [];
            const MASTER_VOL = 0.20;
            const BPM = 75;
            const STEP = (60 / BPM) * 1000;

            function getCtx() {
                if (!ctx) {
                    ctx = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = ctx.createGain();
                    masterGain.gain.value = muted ? 0 : MASTER_VOL;

                    // Spacious reverb
                    reverbNode = ctx.createConvolver();
                    const revLen = ctx.sampleRate * 4;
                    const revBuf = ctx.createBuffer(2, revLen, ctx.sampleRate);
                    for (let c = 0; c < 2; c++) {
                        const d = revBuf.getChannelData(c);
                        for (let i = 0; i < revLen; i++)
                            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / revLen, 1.8);
                    }
                    reverbNode.buffer = revBuf;
                    const revGain = ctx.createGain();
                    revGain.gain.value = 0.5;
                    reverbNode.connect(revGain);
                    revGain.connect(masterGain);
                    masterGain.connect(ctx.destination);
                }
                return ctx;
            }

            // Slow pad layer â€” warm sine/triangle blend, fades in gently
            function makePad(freq, vol, lfoHz, fadeIn) {
                const ac = getCtx();
                const osc1 = ac.createOscillator();
                const osc2 = ac.createOscillator();
                const lfo  = ac.createOscillator();
                const lfoG = ac.createGain();
                const g    = ac.createGain();

                osc1.type = 'sine';     osc1.frequency.value = freq;
                osc2.type = 'triangle'; osc2.frequency.value = freq * 1.002;
                lfo.type  = 'sine';     lfo.frequency.value  = lfoHz;
                lfoG.gain.value = freq * 0.002;

                lfo.connect(lfoG);
                lfoG.connect(osc1.frequency);
                lfoG.connect(osc2.frequency);

                g.gain.setValueAtTime(0, ac.currentTime);
                g.gain.linearRampToValueAtTime(vol, ac.currentTime + fadeIn);

                osc1.connect(g); osc2.connect(g);
                g.connect(masterGain);
                g.connect(reverbNode);
                osc1.start(); osc2.start(); lfo.start();
                nodes.push(osc1, osc2, lfo);
            }

            // Steady sub-bass pulse â€” the groove heartbeat at 75 BPM
            function makeBassPulse() {
                const BASS = [110, 130.81, 146.83, 164.81, 196];
                const pattern = [0, 0, 2, 0, 1, 0, 3, 2];
                let step = 0;
                function beat() {
                    if (!started) return;
                    const freq = BASS[pattern[step % pattern.length]];
                    const ac = getCtx();
                    const osc = ac.createOscillator();
                    const g   = ac.createGain();
                    const lp  = ac.createBiquadFilter();
                    lp.type = 'lowpass'; lp.frequency.value = 280;
                    osc.type = 'sine'; osc.frequency.value = freq;
                    const now = ac.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(0.22, now + 0.02);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.55);
                    osc.connect(lp); lp.connect(g); g.connect(masterGain);
                    osc.start(now); osc.stop(now + 0.6);
                    step++;
                    setTimeout(beat, STEP);
                }
                setTimeout(beat, 2000);
            }

            // Synth melody â€” slow, wandering, evolving Am pentatonic
            function makeMelody() {
                const MELODY = [440, 523.25, 587.33, 659.25, 783.99, 880];
                const PHRASES = [
                    [0, 2, 4, 3, 1, 0],
                    [5, 4, 2, 0, 1, 3],
                    [2, 4, 5, 4, 2, 1],
                    [0, 1, 3, 5, 3, 2],
                ];
                let phraseIdx = 0, noteIdx = 0;
                const NOTE_LEN = 1100;
                function note() {
                    if (!started) return;
                    const phrase = PHRASES[phraseIdx];
                    const freq = MELODY[phrase[noteIdx]];
                    const ac = getCtx();
                    const osc = ac.createOscillator();
                    const g   = ac.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    const now = ac.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(0.055, now + 0.08);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + 1.6);
                    osc.connect(g);
                    g.connect(masterGain);
                    g.connect(reverbNode);
                    osc.start(now); osc.stop(now + 1.7);
                    noteIdx++;
                    if (noteIdx >= phrase.length) {
                        noteIdx = 0;
                        phraseIdx = (phraseIdx + 1) % PHRASES.length;
                        setTimeout(note, NOTE_LEN + 800);
                    } else {
                        setTimeout(note, NOTE_LEN);
                    }
                }
                setTimeout(note, 5000);
            }

            // Hi-frequency shimmer noise â€” like stars twinkling
            function makeSpaceTexture() {
                const ac = getCtx();
                const bufSize = ac.sampleRate * 4;
                const buf = ac.createBuffer(2, bufSize, ac.sampleRate);
                for (let c = 0; c < 2; c++) {
                    const d = buf.getChannelData(c);
                    for (let i = 0; i < bufSize; i++) d[i] = Math.random() * 2 - 1;
                }
                const src = ac.createBufferSource();
                src.buffer = buf; src.loop = true;
                const hp = ac.createBiquadFilter();
                hp.type = 'highpass'; hp.frequency.value = 6000;
                const g = ac.createGain();
                g.gain.setValueAtTime(0, ac.currentTime);
                g.gain.linearRampToValueAtTime(0.06, ac.currentTime + 10);
                src.connect(hp); hp.connect(g);
                g.connect(reverbNode);
                src.start();
                nodes.push(src);
            }

            // Soft rhythmic hi-hat â€” CBL electronic groove feel
            function makeHihat() {
                const HAT_PAT = [1, 0, 1, 1, 0, 1, 0, 1];
                let step = 0;
                function tick() {
                    if (!started) return;
                    if (HAT_PAT[step % HAT_PAT.length]) {
                        const ac = getCtx();
                        const bufSize = Math.floor(ac.sampleRate * 0.04);
                        const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
                        const d = buf.getChannelData(0);
                        for (let i = 0; i < bufSize; i++)
                            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 3);
                        const src = ac.createBufferSource();
                        src.buffer = buf;
                        const hp = ac.createBiquadFilter();
                        hp.type = 'highpass'; hp.frequency.value = 8000;
                        const g = ac.createGain();
                        g.gain.value = 0.055;
                        src.connect(hp); hp.connect(g); g.connect(masterGain);
                        src.start(); src.stop(ac.currentTime + 0.04);
                    }
                    step++;
                    setTimeout(tick, STEP * 2);
                }
                setTimeout(tick, 3000);
            }

            return {
                start() {
                    if (started) return;
                    started = true;
                    getCtx();
                    makePad(110.00, 0.16, 0.07, 6.0);
                    makePad(164.81, 0.12, 0.05, 8.0);
                    makePad(220.00, 0.10, 0.09, 10.0);
                    makePad(261.63, 0.07, 0.06, 12.0);
                    makePad(329.63, 0.05, 0.04, 14.0);
                    makeSpaceTexture();
                    makeBassPulse();
                    makeHihat();
                    makeMelody();
                },
                stop() {
                    if (!started) return;
                    started = false;
                    if (masterGain) {
                        masterGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 2.0);
                    }
                    setTimeout(() => {
                        nodes.forEach(n => { try { n.stop(); } catch(e){} });
                        nodes = [];
                        if (ctx) { ctx.close(); ctx = null; masterGain = null; reverbNode = null; }
                    }, 2100);
                },
                setMute(val) {
                    muted = val;
                    if (masterGain) {
                        masterGain.gain.linearRampToValueAtTime(
                            val ? 0 : MASTER_VOL,
                            (ctx ? ctx.currentTime : 0) + 0.3
                        );
                    }
                },
                isMuted() { return muted; },
                suspend() {
                    if (ctx && ctx.state === 'running') ctx.suspend();
                },
                resume() {
                    if (ctx && ctx.state === 'suspended') ctx.resume();
                }
            };
        })();

        // Mute button logic
        document.getElementById('muteBtn').addEventListener('click', () => {
            const nowMuted = !ambientMusic.isMuted();
            ambientMusic.setMute(nowMuted);
            document.querySelector('#muteBtn .material-symbols-outlined').textContent =
                nowMuted ? 'volume_off' : 'volume_up';
        });
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Simple shoot sound using Web Audio API
        function playShootSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 200;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Function to update word progress (green background fill as you type)
        function updateWordProgress() {
            game.invaders.forEach(invader => {
                if (invader.isDying || !invader.wordElement) return;
                
                // In math mode: never show prefix progress (would reveal answer length proximity)
                if (game.isMathMode) {
                    invader.wordElement.style.setProperty('--progress', '0%');
                    return;
                }
                
                if (game.currentInput && invader.word.startsWith(game.currentInput)) {
                    // Calculate progress percentage
                    const progress = (game.currentInput.length / invader.word.length) * 100;
                    invader.wordElement.style.setProperty('--progress', `${progress}%`);
                } else {
                    // No match, reset progress
                    invader.wordElement.style.setProperty('--progress', '0%');
                }
            });
        }

        // Function to update input display
        function updateInputDisplay() {
            // Always update based on current input
            if (game.currentInput && game.currentInput.length > 0) {
                inputDisplay.classList.add('active');
                
                const isMathTarget = game.isMathMode || (game.targetInvader && game.targetInvader.isMathQuestion);
                if (game.targetInvader && game.targetInvader.word && !isMathTarget) {
                    // Show target word with progress (NOT in math mode to avoid revealing answer)
                    const targetWord = game.targetInvader.word;
                    const typed = game.currentInput;
                    
                    let html = '';
                    for (let i = 0; i < targetWord.length; i++) {
                        if (i < typed.length) {
                            html += `<span class="typed">${targetWord[i]}</span>`;
                        } else {
                            html += `<span class="untyped">${targetWord[i]}</span>`;
                        }
                    }
                    inputDisplay.innerHTML = html;
                } else {
                    // Just show what's being typed (no target yet, or in math mode)
                    inputDisplay.innerHTML = `<span class="typed">${game.currentInput}</span>`;
                }
            } else {
                // Clear display when no input
                inputDisplay.innerHTML = '';
                inputDisplay.classList.remove('active');
            }
        }

        // Error sound effect (using Web Audio API)
        // Error sound effect (low pitched beep)
        function playErrorSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Lower frequency for error sound
            oscillator.frequency.value = 150;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
            
            // Show error state on input display
            inputDisplay.classList.add('error');
            setTimeout(() => {
                inputDisplay.classList.remove('error');
            }, 300);
        }

        // Success sound effect (cheerful ascending melody)
        function playSuccessSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create a more pleasant success sound with multiple notes
            const notes = [
                { freq: 523.25, time: 0, duration: 0.08 },      // C5
                { freq: 659.25, time: 0.06, duration: 0.08 },   // E5
                { freq: 783.99, time: 0.12, duration: 0.12 }    // G5
            ];
            
            notes.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = note.freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + note.time;
                gainNode.gain.setValueAtTime(0.15, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + note.duration);
            });
        }

        // Mobile input handler - converts input events to keyboard events
        mobileInput.addEventListener('input', (e) => {
            if (game.isGameOver || game.isPaused) return;
            
            const newValue = e.target.value;
            const oldValue = game.currentInput;
            
            if (newValue.length > oldValue.length) {
                // Character added
                const newChar = newValue[newValue.length - 1].toLowerCase();
                // Trigger the same logic as keyboard
                const keyEvent = new KeyboardEvent('keydown', { key: newChar });
                document.dispatchEvent(keyEvent);
            } else if (newValue.length < oldValue.length) {
                // Character deleted
                const keyEvent = new KeyboardEvent('keydown', { key: 'Backspace' });
                document.dispatchEvent(keyEvent);
            }
            
            // Keep input field in sync but prevent it from getting too long
            if (mobileInput.value.length > 20) {
                mobileInput.value = mobileInput.value.slice(-10);
            }
        });

        // Keep mobile input focused during game (mobile only)
        mobileInput.addEventListener('blur', () => {
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (!game.isGameOver && !game.isPaused && isMobile) {
                setTimeout(() => mobileInput.focus(), 10);
            }
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (game.isGameOver) return;

            // Challenge mode
            if (game.isChallenge) { handleChallengeInput(e); return; }

            // Sentences mode
            const currentInputMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            if (currentInputMode === 'sentences' && game.isSentenceActive) {
                handleSentenceInput(e);
                return;
            }

            // Spacebar â†’ pause
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                togglePause();
                return;
            }

            if (game.isPaused) return;

            const _mode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            const _isMath = _mode === 'math' || game.isMathMode;

            // â”€â”€ Backspace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (e.key === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
                mobileInput.value = game.currentInput;
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();

            // â”€â”€ Digits (math mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            } else if (_isMath && /^[0-9]$/.test(e.key)) {
                _handleMathKey(e.key);

            // â”€â”€ Letters / digits (word / letter mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            } else if (!_isMath && e.key.length === 1 && /[a-z0-9]/i.test(e.key)) {
                _handleWordKey(e.key.toLowerCase());
            }
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp, loopSession) {
            // If this RAF callback belongs to an old session, silently stop
            if (loopSession !== undefined && loopSession !== _sessionId) return;
            if (game.isGameOver) return;

            if (!game.isPaused) {
                const deltaTime = timestamp - lastTime;

                // Spawn invaders - faster in letter mode
                const spawnInterval = game.isLetterMode ? 800 : game.spawnInterval; // Much faster for letters
                if (timestamp - game.lastSpawn > spawnInterval) {
                    spawnInvader();
                    game.lastSpawn = timestamp;
                }

                // Update invaders
                game.invaders = game.invaders.filter(invader => {
                    if (invader.isDying) return false; // remove dying ones from array
                    invader.update();
                    if (invader.y >= window.innerHeight + 100) {
                        // Invader reached bottom - reset combo
                        resetCombo();
                        game.missedWords++;
                        if (invader.element) invader.element.remove();
                        return false;
                    }
                    return true;
                });

                // Update bullets
                game.bullets = game.bullets.filter(bullet => {
                    const alive = bullet.update();
                    
                    if (!alive) {
                        bullet.remove();
                    }
                    return alive;
                });

                // Continuously update rocket rotation to track target
                if (game.targetInvader && !game.targetInvader.isDying) {
                    rotateRocketToTarget(game.targetInvader);
                }

                // Record performance history periodically for the celebration graph
                if (game.startTime && game.lastPerformanceCheck) {
                    const now = Date.now();
                    const intervalMs = 2000; // sample every 2 seconds
                    if (now - game.lastPerformanceCheck >= intervalMs) {
                        const totalTimeMinutes = (now - game.startTime) / 60000;
                        
                        if (game.mode === 'math') {
                            // Math: track SPS and avg solve time
                            const totalTimeSeconds = (now - game.startTime) / 1000;
                            const currentSps = totalTimeSeconds > 0
                                ? (game.mathQuestionsAnswered / totalTimeSeconds)
                                : 0;
                            const currentAvgSolve = game.mathQuestionsAnswered > 0
                                ? (game.totalMathSolveTime / game.mathQuestionsAnswered / 1000)
                                : 0;
                            game.spmHistory.push(currentSps);
                            game.solveTimeHistory.push(currentAvgSolve);
                        } else {
                            const totalAttempts = game.correctCharacters + game.incorrectAttempts;
                            const currentWpm = totalTimeMinutes > 0
                                ? Math.round((game.correctCharacters / 5) / totalTimeMinutes)
                                : 0;
                            const currentAccuracy = totalAttempts > 0
                                ? Math.round((game.correctCharacters / totalAttempts) * 100)
                                : 0;
                            game.wpmHistory.push(currentWpm);
                            game.accuracyHistory.push(currentAccuracy);
                        }
                        game.lastPerformanceCheck = now;
                    }
                }

                // Progressive difficulty â€” increase speed each time score crosses a new 20-pt threshold
                const currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
                const currentThreshold = Math.floor(game.score / 20) * 20;
                if (game.score > 0 && currentThreshold > game.lastSpeedIncrease) {
                    const steps = (currentThreshold - game.lastSpeedIncrease) / 20;
                    if (currentMode === 'math') {
                        game.invaderSpeed += 0.05 * steps;
                    } else if (currentMode !== 'sentences') {
                        game.invaderSpeed += 0.1 * steps;
                    }
                    game.lastSpeedIncrease = currentThreshold;
                }
            }
            
            lastTime = timestamp;
            requestAnimationFrame(ts => gameLoop(ts, loopSession));
        }

        // Challenge system functions (LEGACY - kept for compatibility)
        function startChallenge() {
            game.isChallenge = true;
            game.isPaused = true;
            game.challengeTimeLeft = 20;
            game.currentInput = '';
            
            // Pick random sentence that hasn't been used
            const unusedSentences = challengeSentences.filter((s, i) => 
                !game.completedChallenges.includes(challengeMilestones[challengeSentences.indexOf(s)])
            );
            const randomSentence = challengeSentences[Math.floor(Math.random() * challengeSentences.length)];
            
            // Setup challenge screen
            const challengeScreen = document.getElementById('challengeScreen');
            const challengeSentence = document.getElementById('challengeSentence');
            const challengeTimer = document.getElementById('challengeTimer');
            const challengeInput = document.getElementById('challengeInput');
            
            // Wrap each character in a span
            challengeSentence.innerHTML = randomSentence.split('').map(char => 
                `<span class="char">${char}</span>`
            ).join('');
            
            challengeTimer.textContent = `${game.challengeTimeLeft} Sec`;
            challengeInput.textContent = '';
            challengeScreen.classList.add('show');
            
            // Hide normal game keyboard during challenge
            const normalKeyboard = document.getElementById('onScreenKeyboard');
            normalKeyboard.classList.add('hide-for-challenge');
            
            // Start countdown
            game.challengeTimer = setInterval(() => {
                game.challengeTimeLeft--;
                challengeTimer.textContent = `${game.challengeTimeLeft} Sec`;
                
                if (game.challengeTimeLeft <= 0) {
                    failChallenge();
                }
            }, 1000);
            
            // Update current character highlight
            updateChallengeProgress();
        }

        function updateChallengeProgress() {
            const challengeSentence = document.getElementById('challengeSentence');
            const chars = challengeSentence.querySelectorAll('.char');
            const input = game.currentInput;
            
            chars.forEach((char, index) => {
                char.classList.remove('correct', 'current');
                if (index < input.length) {
                    char.classList.add('correct');
                } else if (index === input.length) {
                    char.classList.add('current');
                }
            });
        }

        function completeChallenge() {
            clearInterval(game.challengeTimer);
            game.isChallenge = false;
            game.isPaused = false;
            game.currentInput = '';
            
            const challengeScreen = document.getElementById('challengeScreen');
            challengeScreen.classList.remove('show');
            
            // Restore correct keyboard based on current mode
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                if (game.isMathMode) {
                    // Math mode - show number keyboard
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    // Word/Letter mode - show letter keyboard
                    normalKeyboard.classList.remove('hide-for-challenge');
                    normalKeyboard.style.display = 'flex';
                    numberKeyboard.classList.remove('show');
                }
            } else {
                // Desktop - just unhide
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                normalKeyboard.classList.remove('hide-for-challenge');
            }
            
            // Bonus points for completing challenge
            game.score += 50;
            scoreValue.textContent = game.score;
            
            // Refocus input
            if (isMobile) {
                mobileInput.focus();
            }
        }

        function failChallenge() {
            clearInterval(game.challengeTimer);
            game.isChallenge = false;
            game.isPaused = false;
            game.currentInput = '';
            
            const challengeScreen = document.getElementById('challengeScreen');
            challengeScreen.classList.remove('show');
            
            // Restore correct keyboard based on current mode
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                if (game.isMathMode) {
                    // Math mode - show number keyboard
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    // Word/Letter mode - show letter keyboard
                    normalKeyboard.classList.remove('hide-for-challenge');
                    normalKeyboard.style.display = 'flex';
                    numberKeyboard.classList.remove('show');
                }
            } else {
                // Desktop - just unhide
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                normalKeyboard.classList.remove('hide-for-challenge');
            }
            
            // Penalty for failing challenge
            const penalty = 50;
            game.score = Math.max(0, game.score - penalty);
            scoreValue.textContent = game.score;
            
            // Check if game over
            if (game.score === 0) {
                gameOver();
            }
            
            // Refocus input
            if (isMobile) {
                mobileInput.focus();
            }
        }

        function handleChallengeInput(e) {
            const challengeInput = document.getElementById('challengeInput');
            const challengeSentenceEl = document.getElementById('challengeSentence');
            const targetSentence = challengeSentenceEl.textContent;
            
            if (e.key === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
            } else if (e.key.length === 1) {
                // Only add character if it matches the next expected character (case-insensitive)
                const nextChar = targetSentence[game.currentInput.length];
                if (e.key.toLowerCase() === nextChar.toLowerCase()) {
                    game.currentInput += nextChar; // Use the actual character from sentence (preserves case)
                }
            }
            
            // Update display
            challengeInput.textContent = game.currentInput;
            updateChallengeProgress();
            
            // Check if completed
            if (game.currentInput === targetSentence) {
                completeChallenge();
            }
        }

        function handleSentenceInput(e) {
            if (!game.isSentenceActive || !game.currentSentenceText) return;
            
            const targetSentence = game.currentSentenceText;
            
            if (e.key === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
            } else if (e.key.length === 1) {
                const nextChar = targetSentence[game.currentInput.length];
                if (nextChar !== undefined && e.key.toLowerCase() === nextChar.toLowerCase()) {
                    game.currentInput += nextChar;
                    game.correctCharacters++;
                    if (game.mode === 'journey') game.journeyStats.sentences.correctChars++;
                } else if (nextChar !== undefined) {
                    // Wrong key
                    game.incorrectAttempts++;
                    if (game.mode === 'journey') game.journeyStats.sentences.incorrectKeys++;
                    resetCombo();
                    playErrorSound();
                }
            }
            
            updateSentenceProgress();
            
            // Check completion
            if (game.currentInput === targetSentence) {
                completeSentence();
            }
        }

        // Challenge keyboard event listeners (mobile/tablet)
        const challengeKeys = document.querySelectorAll('.challenge-key');
        challengeKeys.forEach(key => {
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!game.isChallenge) return;
                
                const keyValue = key.getAttribute('data-key');
                
                if (keyValue === 'backspace') {
                    handleChallengeInput({ key: 'Backspace' });
                } else if (keyValue === ' ') {
                    handleChallengeInput({ key: ' ' });
                } else {
                    handleChallengeInput({ key: keyValue });
                }
                
                // Visual feedback
                key.style.background = 'rgba(16, 185, 129, 0.5)';
                setTimeout(() => {
                    key.style.background = '';
                }, 100);
            });
            
            key.addEventListener('click', (e) => {
                e.preventDefault();
                if (!game.isChallenge) return;
                
                const keyValue = key.getAttribute('data-key');
                
                if (keyValue === 'backspace') {
                    handleChallengeInput({ key: 'Backspace' });
                } else if (keyValue === ' ') {
                    handleChallengeInput({ key: ' ' });
                } else {
                    handleChallengeInput({ key: keyValue });
                }
            });
        });

        // Game over
        function gameOver() {
            // Use the celebration screen for all game-over scenarios
            if (game.isGameOver) return;
            showCelebration();
        }

        // â”€â”€ Nuclear cleanup: call before every mode/restart transition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function fullCleanup() {
            // Stop game loop by incrementing sessionId - all pending RAF/setTimeout
            // callbacks that captured the old id will see the mismatch and bail out.
            _sessionId++;
            game.isGameOver = true;
            game.isPaused   = false;

            // Clear sentence timer
            if (game.sentenceTimer) {
                clearInterval(game.sentenceTimer);
                game.sentenceTimer = null;
            }
            game.isSentenceActive  = false;
            game.currentSentenceText = '';
            game.currentInput        = '';

            // Kill all invader/bullet DOM elements
            game.invaders.forEach(z => { try { if (z.element) z.element.remove(); } catch(e){} });
            game.bullets.forEach(b  => { try { b.remove(); } catch(e){} });
            game.invaders = [];
            game.bullets  = [];

            // Nuke any orphaned DOM leftovers
            document.querySelectorAll('.invader, .bullet').forEach(el => el.remove());

            // Reset sentences overlay completely
            const overlay = document.getElementById('sentencesOverlay');
            const box     = document.getElementById('sentencesBox');
            if (overlay) overlay.classList.remove('show');
            if (box) {
                box.classList.remove('animate-in', 'animate-out');
                // Force reflow so any pending CSS transitions stop
                void box.offsetWidth;
            }

            // Reset phase-transition overlay
            const phaseOverlay = document.getElementById('phaseTransitionOverlay');
            if (phaseOverlay) {
                phaseOverlay.style.opacity  = '0';
                phaseOverlay.style.display  = 'none';
            }

            // Reset keyboards to default
            const normalKb = document.getElementById('onScreenKeyboard');
            const numberKb = document.getElementById('numberKeyboard');
            if (normalKb) { normalKb.style.display = ''; normalKb.classList.remove('hide-for-challenge'); }
            if (numberKb) { numberKb.classList.remove('show'); numberKb.style.display = ''; }

            // Reset challenge screen
            const challengeScreen = document.getElementById('challengeScreen');
            if (challengeScreen) challengeScreen.classList.remove('show');

            // Reset pause overlay
            const pauseOverlay = document.getElementById('pauseOverlay');
            if (pauseOverlay) pauseOverlay.classList.remove('show');

            // Reset input display
            const inputDisplay = document.getElementById('inputDisplay');
            if (inputDisplay) { inputDisplay.innerHTML = ''; inputDisplay.classList.remove('active', 'error'); }
            const mobileIn = document.getElementById('mobileInput');
            if (mobileIn) mobileIn.value = '';

            // Reset mode flags
            game.isMathMode         = false;
            game.isLetterMode       = false;
            game._phaseTransitioning = false;
            game.targetInvader      = null;
        }

        // Speed multiplier setting
        let speedMultiplier = 1;
        const speedLevels = [1, 2, 3];

        const speedDisplay = document.getElementById('speedDisplay');

        // Map speed multiplier â†’ sentence countdown duration
        // 1x = 24s, 2x = 18s, 3x = 12s
        const sentenceSpeedDurations = { 1: 24, 2: 18, 3: 12 };

        speedDisplay.addEventListener('click', () => {
            // Only active during sentences mode (standalone or journey sentences phases)
            const currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            if (currentMode !== 'sentences') return;
            const currentIndex = speedLevels.indexOf(speedMultiplier);
            speedMultiplier = speedLevels[(currentIndex + 1) % speedLevels.length];
            speedDisplay.textContent = speedMultiplier + 'x';

            if (currentMode === 'sentences') {
                // Sentences mode: if a sentence is active, dismiss it and re-show
                // the SAME sentence with the new duration (full card fade-in from top)
                if (game.isSentenceActive) {
                    // Stop the running countdown
                    if (game.sentenceTimer) {
                        clearInterval(game.sentenceTimer);
                        game.sentenceTimer = null;
                    }
                    // Remember the current sentence so we can replay it
                    const savedSentence = game.currentSentenceText;
                    const newDuration   = sentenceSpeedDurations[speedMultiplier] || 24;

                    // Mark inactive so guards inside the old interval don't interfere
                    game.isSentenceActive = false;
                    game.currentInput = '';

                    // Slide out the card, then re-spawn it with the new duration
                    const box     = document.getElementById('sentencesBox');
                    const overlay = document.getElementById('sentencesOverlay');
                    const sid     = _sessionId;

                    box.classList.remove('animate-in');
                    void box.offsetWidth;
                    box.classList.add('animate-out');

                    setTimeout(() => {
                        if (_sessionId !== sid) return; // session changed, abort
                        overlay.classList.remove('show');
                        box.classList.remove('animate-out');

                        // Re-populate card with the same sentence + new duration
                        game.isSentenceActive = true;
                        game.currentInput = '';
                        game.currentSentenceText = savedSentence;
                        game.sentenceTimeLeft = newDuration;

                        const textEl  = document.getElementById('sentencesText');
                        const timerEl = document.getElementById('sentencesTimer');
                        const fillEl  = document.getElementById('sentencesDurationFill');

                        const words = savedSentence.split(' ');
                        textEl.innerHTML = words.map(word =>
                            `<span class="word">${word.split('').map(char => `<span class="char">${char}</span>`).join('')}</span>`
                        ).join('<span class="char space">&nbsp;</span>');

                        timerEl.textContent = `${newDuration}s`;
                        timerEl.style.color = 'rgba(255,255,255,0.5)';
                        fillEl.style.transition = 'none';
                        fillEl.style.width = '100%';
                        const hintEl2 = document.getElementById('sentencesHint');
                        if (hintEl2) hintEl2.textContent = 'Start typing...';

                        // Slide in from top
                        overlay.classList.add('show');
                        box.classList.remove('animate-out');
                        void box.offsetWidth;
                        box.classList.add('animate-in');

                        // Start fresh countdown after slide-in (400ms)
                        const _spawnSession = _sessionId;
                        setTimeout(() => {
                            if (_sessionId !== _spawnSession || !game.isSentenceActive) return;
                            if (game.sentenceTimer) {
                                clearInterval(game.sentenceTimer);
                                game.sentenceTimer = null;
                            }
                            let localDuration = newDuration;
                            game.sentenceTimer = setInterval(() => {
                                if (_sessionId !== _spawnSession || !game.isSentenceActive) {
                                    clearInterval(game.sentenceTimer);
                                    game.sentenceTimer = null;
                                    return;
                                }
                                if (game.isPaused) return;
                                game.sentenceTimeLeft--;
                                timerEl.textContent = `${Math.max(0, game.sentenceTimeLeft)}s`;
                                timerEl.style.color = game.sentenceTimeLeft <= 5 ? '#ff4757' : 'rgba(255,255,255,0.5)';
                                const pct = Math.max(0, (game.sentenceTimeLeft / localDuration) * 100);
                                fillEl.style.transition = 'width 1s linear';
                                fillEl.style.width = pct + '%';
                                if (game.sentenceTimeLeft <= 0) {
                                    skipSentence();
                                }
                            }, 1000);
                        }, 400);
                    }, 360); // match dismissSentenceBox animation duration
                }
            } else {
                // Words / letters / math: apply new speed to existing invaders
                game.invaders.forEach(inv => {
                    if (!inv.isDying) {
                        inv.speedY = game.invaderSpeed * (0.8 + Math.random() * 0.4) * speedMultiplier;
                    }
                });
            }
        });

        // Update speed button state based on mode
        function updateSpeedButtonState() {
            const currentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            if (currentMode === 'sentences') {
                // Sentences: fully active, visible
                speedDisplay.style.display = '';
                speedDisplay.style.opacity = '1';
                speedDisplay.style.cursor = 'pointer';
                speedDisplay.title = '';
            } else if (game.mode === 'journey') {
                // Journey non-sentences phases: hide (auto-controlled)
                speedDisplay.style.display = 'none';
            } else {
                // Words / math standalone: hide â€” speed auto-scales with score
                speedDisplay.style.display = 'none';
            }
        }

        // Restart game
        function restartGame() {
            fullCleanup();
            ambientMusic.stop();
            game.completedChallenges = [];

            // Hide game container and show time selection screen
            gameContainer.classList.add('hidden');
            timeSelection.classList.remove('hidden');
            gameOverScreen.classList.remove('show');
            topbar.classList.remove('show');
        }

        // Start game with selected difficulty
        function startGame(mode) {
            // Full nuclear cleanup of any previous game session
            fullCleanup();
            // Stamp this session so async callbacks from old sessions self-abort
            _sessionId++;
            const mySession = _sessionId;

            // Mode settings
            const modeSettings = {
                'words': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.3,
                    maxInvaders: 6
                },
                'sentences': {
                    spawnInterval: 3000,
                    invaderSpeed: 0.4,
                    maxInvaders: 3
                },
                'math': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.35,
                    maxInvaders: 4
                },
                'journey': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.3,
                    maxInvaders: 5
                }
            };
            
            const settings = modeSettings[mode];
            
            // Reset game state
            game.score = 0;
            game.currentInput = '';
            game.invaders = [];
            game.bullets = [];
            game.targetInvader = null;
            game.isGameOver = false;
            game.isPaused = false;
            game.lastSpawn = 0;
            game.mode = mode;
            game.journeyPhase = 1;
            game.spawnInterval = settings.spawnInterval;
            game.invaderSpeed = settings.invaderSpeed;
            game.maxInvaders = settings.maxInvaders;
            game.lastSpeedIncrease = 0;
            
            // Reset combo system
            game.consecutiveHits = 0;
            game.comboMultiplier = 1;
            updateComboDisplay();
            
            // Reset celebration and stats tracking
            game.celebrationShown = false;
            game.isMathMode = false;
            game.isLetterMode = false;
            game._phaseTransitioning = false;
            game.completedChallenges = [];
            // Reset speed multiplier
            speedMultiplier = (mode === 'journey') ? 2 : 1;
            speedDisplay.textContent = speedMultiplier + 'x';
            game.startTime = Date.now();
            game.totalCharactersTyped = 0;
            game.correctCharacters = 0;
            game.incorrectAttempts = 0;
            game.missedWords = 0;
            game.consecutiveMisses = 0;
            game.fastestWordTime = null;
            game.wordStartTime = null;
            game.wpmHistory = [];
            game.accuracyHistory = [];
            game.lastPerformanceCheck = Date.now();
            game.mathQuestionsAnswered = 0;
            game.totalMathSolveTime = 0;
            game.mathQuestionStartTime = null;
            game.spmHistory = [];
            game.solveTimeHistory = [];
            game.isSentenceActive = false;
            game.sentenceTimer = null;
            game.sentenceTimeLeft = 30;
            game.currentSentenceIndex = 0;
            game.usedSentences = [];
            game.consecutiveSentenceFailures = 0;
            game.journeyStats = {
                words:     { wordsHit: 0, wordsMissed: 0, incorrectKeys: 0, correctChars: 0 },
                sentences: { completed: 0, skipped: 0, incorrectKeys: 0, correctChars: 0 },
                math:      { solved: 0, missed: 0, fastSolves: 0, totalSolveTime: 0 },
                letters:   { hit: 0, missed: 0 }
            };
            
            // Clear mobile input value
            mobileInput.value = '';
            
            // Reset UI
            scoreValue.textContent = '0';
            scoreValue.classList.remove('score-increase', 'score-decrease');
            const modeNames = {
                'words': 'Words',
                'sentences': 'Sentences', 
                'math': 'Math',
                'journey': 'Adventure'
            };
            difficultyDisplay.textContent = modeNames[mode];
            
            // Update speed button state for the selected mode
            updateSpeedButtonState();
            
            // Set pause button icon
            const pauseIcon = pauseBtn.querySelector('.material-symbols-outlined');
            if (pauseIcon) pauseIcon.textContent = 'pause';
            
            rotateRocketToTarget(null);
            
            // Hide time selection and show game container
            timeSelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            topbar.classList.add('show');
            ambientMusic.start();
            // Sync mute icon with current mute state
            document.querySelector('#muteBtn .material-symbols-outlined').textContent =
                ambientMusic.isMuted() ? 'volume_off' : 'volume_up';
            
            // Focus mobile input only on mobile/tablet devices
            // Desktop will use document keydown listener directly
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (isMobile) {
                // Always clear any inline display styles left over from a previous session
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                // For math mode, show number keyboard immediately
                if (mode === 'math') {
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    normalKeyboard.style.display = '';
                    normalKeyboard.classList.remove('hide-for-challenge');
                    numberKeyboard.style.display = '';
                    numberKeyboard.classList.remove('show');
                }

                // Show spacebar row only for sentences mode (standalone) or journey sentences phases (2 and 6)
                const spacebarRow = document.getElementById('spacebarRow');
                if (spacebarRow) {
                    const journeySentencesPhase = mode === 'journey' && (getJourneyPhaseNumber() === 2 || getJourneyPhaseNumber() === 6);
                    spacebarRow.style.display = (mode === 'sentences' || journeySentencesPhase) ? 'flex' : 'none';
                }

                // Mobile - use the hidden input to capture keyboard
                requestAnimationFrame(() => {
                    mobileInput.focus();
                });
                setTimeout(() => mobileInput.focus(), 50);
                setTimeout(() => mobileInput.focus(), 100);
            } else {
                // Desktop - ensure mobileInput is blurred so document keydown works
                mobileInput.blur();
                // Focus on game container or document body instead
                gameContainer.focus();
            }
            
            // Restart game loop, tagged with this session id
            lastTime = performance.now();
            requestAnimationFrame(ts => gameLoop(ts, mySession));
        }

        // Pause microcopy messages
        const pauseMicrocopyMessages = [
            'Take a deep breath',
            'Stretch your fingers',
            'Are you ready?',
            'You can do this!',
            'This is easy, right?'
        ];

        // Toggle pause
        // Show celebration screen at score 1000
        function showCelebration() {
            fullCleanup();
            game.isPaused = true;
            document.getElementById('gameContainer').classList.add('hidden');
            
            const totalTimeSeconds = (Date.now() - game.startTime) / 1000;
            const totalTimeMinutes = totalTimeSeconds / 60;
            const isMathModeGame = game.mode === 'math';
            const isJourney = game.mode === 'journey';

            // Rank helper
            function getRank(s) {
                if (s >= 900) return 'OTAI';
                if (s >= 800) return 'LEGEND';
                if (s >= 700) return 'JAGUH';
                if (s >= 600) return 'ELITE';
                if (s >= 500) return 'GEMPAK';
                if (s >= 400) return 'WIRA';
                if (s >= 300) return 'POWER';
                if (s >= 200) return 'BLUR';
                if (s >= 100) return 'MEH';
                return 'NOOB';
            }

            document.getElementById('playerRank').textContent = getRank(game.score);
            animateValue('celebrationScoreValue', 0, game.score, 1200);

            const leftStats   = document.querySelector('.left-stats');
            const bottomStats = document.querySelector('.bottom-stats');
            const journeyTabs = document.getElementById('journeyTabs');
            const rocketIcon  = document.getElementById('celebrationRocketIcon');

            if (isJourney) {
                // Hide standard stats, show journey tabs
                leftStats.style.display   = 'none';
                bottomStats.style.display = 'none';
                rocketIcon.style.display  = 'none';
                journeyTabs.style.display = 'flex';
                document.getElementById('graphView').style.display      = 'none';
                document.getElementById('speedoView').style.display     = '';
                document.getElementById('graphViewToggle').style.display = 'none';
                document.getElementById('celebrationShuffleBtn').style.display = 'none';
                document.getElementById('celebrationPreviewBtn').style.display = 'none';

                // Populate words tab
                const jw = game.journeyStats.words;
                document.getElementById('jw-hit').textContent    = jw.wordsHit;
                document.getElementById('jw-missed').textContent = jw.wordsMissed;
                document.getElementById('jw-wrong').textContent  = jw.incorrectKeys;

                // Populate sentences tab
                const js = game.journeyStats.sentences;
                const sentenceWpm = totalTimeMinutes > 0 ? Math.round((js.correctChars / 5) / totalTimeMinutes) : 0;
                document.getElementById('js-done').textContent    = js.completed;
                document.getElementById('js-skipped').textContent = js.skipped;
                document.getElementById('js-wrong').textContent   = sentenceWpm;

                // Populate math tab
                const jm = game.journeyStats.math;
                document.getElementById('jm-solved').textContent = jm.solved;
                document.getElementById('jm-missed').textContent = jm.missed;
                document.getElementById('jm-fast').textContent   = jm.fastSolves > 0 ? jm.fastSolves + 'âš¡ï¸' : '0';

                // Populate letters tab
                const jl = game.journeyStats.letters;
                const lps = totalTimeSeconds > 0 ? (jl.hit / totalTimeSeconds).toFixed(2) : '0.00';
                document.getElementById('jl-hit').textContent    = jl.hit;
                document.getElementById('jl-missed').textContent = jl.missed;
                document.getElementById('jl-lps').textContent    = lps;

                // Reset tabs to first tab active
                document.querySelectorAll('.journey-tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.journey-tab-content').forEach(c => c.classList.remove('active'));
                document.querySelector('.journey-tab-btn[data-tab="words"]').classList.add('active');
                document.getElementById('jtab-words').classList.add('active');

                game._mathGraphMode = false;

            } else {
                // Standard modes: restore graph and toggle
                document.getElementById('graphView').style.display       = '';
                document.getElementById('graphViewToggle').style.display = '';
                document.getElementById('celebrationShuffleBtn').style.display = 'none';
                document.getElementById('celebrationPreviewBtn').style.display = 'none';
                // Standard modes (math or words/sentences)
                leftStats.style.display   = '';
                bottomStats.style.display = '';
                rocketIcon.style.display  = '';
                journeyTabs.style.display = 'none';
                rocketIcon.style.display  = '';
                journeyTabs.style.display = 'none';

                if (isMathModeGame) {
                    const questionsAnswered = game.mathQuestionsAnswered || 0;
                    const sps = totalTimeSeconds > 0 ? (questionsAnswered / totalTimeSeconds).toFixed(2) : '0.00';
                    const spsNum = parseFloat(sps);
                    const avgSolveTime = questionsAnswered > 0
                        ? ((game.totalMathSolveTime || 0) / questionsAnswered / 1000).toFixed(1)
                        : 0;
                    const wrongAnswers = game.incorrectAttempts;

                    document.getElementById('celebrationWpmLabel').textContent = 'SPS';
                    document.getElementById('celebrationAccuracyLabel').textContent = 'AVG SOLVE';
                    document.getElementById('celebrationIncorrectLabel').textContent = 'Wrong answers';

                    const spsEl = document.getElementById('celebrationWpm');
                    let spsAnim = 0;
                    const spsSteps = 60;
                    const spsInc = spsNum / spsSteps;
                    const spsInterval = setInterval(() => {
                        spsAnim += spsInc;
                        if (spsAnim >= spsNum) { spsAnim = spsNum; clearInterval(spsInterval); }
                        spsEl.textContent = spsAnim.toFixed(2);
                    }, 2000 / spsSteps);
                    document.getElementById('celebrationAccuracy').textContent = avgSolveTime + 's';
                    document.getElementById('celebrationAccuracy').style.color = '#10b981';
                    document.getElementById('celebrationAccuracy').style.textShadow = '0 0 6px rgba(16, 185, 129, 0.2)';
                    animateValue('celebrationIncorrect', 0, wrongAnswers, 1200);
                    animateValue('celebrationMissed', 0, game.missedWords, 1200);
                    game._mathGraphMode = true;

                } else {
                    const wordsTyped = game.correctCharacters / 5;
                    const wpm = Math.round(wordsTyped / totalTimeMinutes);
                    const totalAttempts = game.correctCharacters + game.incorrectAttempts;
                    const accuracy = totalAttempts > 0 ? Math.round((game.correctCharacters / totalAttempts) * 100) : 0;

                    document.getElementById('celebrationWpmLabel').textContent = 'WPM';
                    document.getElementById('celebrationAccuracyLabel').textContent = 'ACCURACY';
                    document.getElementById('celebrationIncorrectLabel').textContent = 'Incorrect attempts';
                    document.getElementById('celebrationAccuracy').style.color = '';
                    document.getElementById('celebrationAccuracy').style.textShadow = '';
                    game._mathGraphMode = false;

                    animateValue('celebrationWpm', 0, wpm, 1200);
                    animateValue('celebrationAccuracy', 0, accuracy, 1200);
                    animateValue('celebrationIncorrect', 0, game.incorrectAttempts, 1200);
                    animateValue('celebrationMissed', 0, game.missedWords, 1200);
                }
            }
            
            // Update graph time labels with actual clock times
            const startDate = new Date(game.startTime);
            const endDate = new Date();
            
            // Format times as HH:MM or H:MM
            const formatTime = (date) => {
                const hours = date.getHours();
                const minutes = date.getMinutes();
                return `${hours}:${minutes.toString().padStart(2, '0')}`;
            };
            
            const endSeconds = Math.floor(totalTimeSeconds);
            const endMinutes = Math.floor(totalTimeMinutes);
            const durationLabel = totalTimeSeconds < 60
                ? `(${endSeconds} sec)`
                : `(${endMinutes} min)`;
            document.getElementById('graphStartTime').textContent = formatTime(startDate);
            document.getElementById('graphCenterTime').textContent = durationLabel;
            document.getElementById('graphEndTime').textContent = formatTime(endDate);
            
            // Update graph legend labels based on mode
            const graphLegend = document.getElementById('graphLegend');
            if (graphLegend) {
                if (isMathModeGame) {
                    graphLegend.innerHTML = '<span style="color:#FFD400">â–  SPS</span> &nbsp; <span style="color:#10b981">â–  Avg Solve Time</span>';
                } else {
                    graphLegend.innerHTML = '<span style="color:#FFD400">â–  WPM</span> &nbsp; <span style="color:#10b981">â–  Accuracy</span>';
                }
            }
            
            // Hide keyboard on mobile/tablet
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            if (isMobile) {
                document.getElementById('onScreenKeyboard').style.display = 'none';
                document.getElementById('numberKeyboard').classList.remove('show');
            }
            
            // Hide default top bar
            document.getElementById('topbar').classList.remove('show');
            
            // Draw appropriate visualization
            if (isJourney) {
                setTimeout(() => drawSpeedometer(), 50);
            } else {
                drawPerformanceGraph();
                setGraphView('graph');
            }
            
            // Show celebration screen
            document.getElementById('celebrationScreen').style.display = 'flex';
            
            // Initialize 3D Hover Effect for Celebration Card (after showing and drawing)
            setTimeout(() => {
                const celebrationCardWrapper = document.getElementById('celebrationCardWrapper');
                if (celebrationCardWrapper) {
                    celebrationCardWrapper.addEventListener('mousemove', (e) => {
                        const rect = celebrationCardWrapper.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;
                        
                        // Calculate rotation (inverted for natural feel)
                        const rotateX = ((y - centerY) / centerY) * -15; // Max 15 degrees
                        const rotateY = ((x - centerX) / centerX) * 15; // Max 15 degrees
                        
                        celebrationCardWrapper.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                    });
                    
                    celebrationCardWrapper.addEventListener('mouseleave', () => {
                        celebrationCardWrapper.style.transform = 'rotateX(0deg) rotateY(0deg)';
                    });
                }
            }, 100);
        }
        
        // Toggle between graph and speedometer views
        let _graphViewCurrent = 'graph';

        function toggleGraphView() {
            const graphView = document.getElementById('graphView');
            const speedoView = document.getElementById('speedoView');
            if (!graphView || !speedoView) return;

            if (_graphViewCurrent === 'graph') {
                graphView.style.display  = 'none';
                speedoView.style.display = '';
                _graphViewCurrent = 'speedo';
                drawSpeedometer();
            } else {
                graphView.style.display  = '';
                speedoView.style.display = 'none';
                _graphViewCurrent = 'graph';
                drawPerformanceGraph();
            }
        }

        function setGraphView(view) {
            const graphView  = document.getElementById('graphView');
            const speedoView = document.getElementById('speedoView');
            if (!graphView || !speedoView) return;
            _graphViewCurrent = view;
            if (view === 'graph') {
                graphView.style.display  = '';
                speedoView.style.display = 'none';
            } else {
                graphView.style.display  = 'none';
                speedoView.style.display = '';
                drawSpeedometer();
            }
        }

        let _speedoRaf = null;

        function drawSpeedometer() {
            // Cancel any in-progress animation before starting a new one
            if (_speedoRaf) { cancelAnimationFrame(_speedoRaf); _speedoRaf = null; }
            const canvas = document.getElementById('speedometerCanvas');
            if (!canvas) return;

            const dpr       = window.devicePixelRatio || 1;
            const cssWidth  = canvas.offsetWidth || 520;
            const GLOW_PAD  = 24;   // extra canvas margin so shadowBlur never clips

            // Geometry based on drawable area (cssWidth - 2*GLOW_PAD)
            const trackW_pre = 30;
            const drawW      = cssWidth - GLOW_PAD * 2;
            const R_pre      = (drawW / 2) - (trackW_pre / 2) - 4;
            const cy_pre     = R_pre + (trackW_pre / 2) + 4;
            const cssHeight  = Math.ceil(cy_pre + (trackW_pre / 2) + 4 + GLOW_PAD);

            canvas.width        = cssWidth  * dpr;
            canvas.height       = cssHeight * dpr;
            canvas.style.width  = cssWidth  + 'px';
            canvas.style.height = cssHeight + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            // Shift origin right+down by GLOW_PAD so arc has shadow room on all sides
            ctx.translate(GLOW_PAD, GLOW_PAD);

            // W/H = drawable area (inside the glow padding)
            const W = cssWidth - GLOW_PAD * 2;
            const H = cssHeight - GLOW_PAD;

            // â”€â”€ Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const RANKS     = ['NOOB','MEH','BLUR','POWER','WIRA','GEMPAK','ELITE','JAGUH','LEGEND','OTAI'];
            const SCORE_MAX = 1000;
            const score     = Math.min(game.score || 0, SCORE_MAX);
            const rankIndex = score >= 900 ? 9 : score >= 800 ? 8 : score >= 700 ? 7
                            : score >= 600 ? 6 : score >= 500 ? 5 : score >= 400 ? 4
                            : score >= 300 ? 3 : score >= 200 ? 2 : score >= 100 ? 1 : 0;
            const rankLabel   = RANKS[rankIndex];
            const needleRatio = score / SCORE_MAX;

            // â”€â”€ Geometry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const trackW = 30;
            const half   = trackW / 2;

            const cx  = W / 2;
            // R driven by available width. cy then placed so arc top = half + 4px from top.
            const R   = (W / 2) - half - 4;
            const cy  = R + half + 4;     // arc top sits at exactly half+4 from canvas top

            const START = Math.PI;
            const END   = 0;

            // Text anchored at cy â€” the arc bottom / pivot row
            const textCy = cy;

            function drawFrame(ratio, glowAlpha) {
                // Clear full canvas including glow padding (translate is active so offset negatively)
                ctx.clearRect(-GLOW_PAD, -GLOW_PAD, cssWidth, cssHeight);

                // â”€â”€ Background arc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ctx.beginPath();
                ctx.arc(cx, cy, R, START, END, false);
                ctx.strokeStyle = 'rgba(255,255,255,0.07)';
                ctx.lineWidth   = trackW;
                ctx.lineCap     = 'round';
                ctx.stroke();

                // â”€â”€ Gradient fill arc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Draw ONLY from START to fillEnd â€” lineCap:round adds the
                // rounded cap at both ends automatically, no clip needed.
                if (ratio > 0.001) {
                    const fillEnd = START + ratio * Math.PI;

                    // Base arc
                    ctx.beginPath();
                    ctx.arc(cx, cy, R, START, fillEnd, false);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth   = trackW;
                    ctx.lineCap     = 'round';
                    ctx.stroke();

                    // Glow overlay â€” fades in after sweep (glowAlpha 0â†’1)
                    if (glowAlpha > 0) {
                        ctx.save();
                        ctx.globalAlpha = glowAlpha * 0.6;
                        ctx.shadowColor = 'rgba(255,255,255,1)';
                        ctx.shadowBlur  = 20;
                        ctx.beginPath();
                        ctx.arc(cx, cy, R, START, fillEnd, false);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth   = trackW;
                        ctx.lineCap     = 'round';
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // â”€â”€ Centre text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'alphabetic';

                ctx.font         = `bold 11px 'Press Start 2P', monospace`;
                ctx.fillStyle    = '#ffffff';
                ctx.shadowColor  = 'rgba(255,255,255,0.25)';
                ctx.shadowBlur   = 6;
                ctx.fillText(rankLabel, cx, textCy);
                ctx.shadowBlur   = 0;

                ctx.font      = `8px 'Press Start 2P', monospace`;
                ctx.fillStyle = 'rgba(255,255,255,0.45)';
                ctx.fillText(`${score}/${SCORE_MAX}`, cx, textCy + 18);
            }

            // â”€â”€ Two-phase animation: sweep (900ms) then glow fade-in (400ms) â”€â”€
            const sweepDuration = 900;
            const glowDuration  = 400;
            const startTime     = performance.now();

            function animate(now) {
                const elapsed = now - startTime;

                if (elapsed < sweepDuration) {
                    // Phase 1: sweep
                    const t     = elapsed / sweepDuration;
                    const eased = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
                    drawFrame(eased * needleRatio, 0);
                    _speedoRaf = requestAnimationFrame(animate);
                } else {
                    // Phase 2: glow fade-in
                    const gt      = Math.min((elapsed - sweepDuration) / glowDuration, 1);
                    const gEased  = gt < 0.5 ? 2*gt*gt : -1+(4-2*gt)*gt;
                    drawFrame(needleRatio, gEased);
                    if (gt < 1) { _speedoRaf = requestAnimationFrame(animate); }
                    else        { _speedoRaf = null; }
                }
            }

            _speedoRaf = requestAnimationFrame(animate);
        }

        function drawPerformanceGraph() {
            const canvas = document.getElementById('performanceGraph');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas (transparent background)
            ctx.clearRect(0, 0, width, height);
            
            const isMathGraph = game._mathGraphMode;
            
            let primaryData, secondaryData;
            
            if (isMathGraph) {
                // Math mode: SPM (yellow) vs Avg Solve Time (green)
                primaryData = game.spmHistory.slice();
                secondaryData = game.solveTimeHistory.slice();
                
                if (primaryData.length < 2 || secondaryData.length < 2) {
                    const totalTimeMinutes = (Date.now() - game.startTime) / 60000;
                    const questionsAnswered = game.mathQuestionsAnswered || 0;
                    const finalSpm = totalTimeMinutes > 0 ? Math.round(questionsAnswered / totalTimeMinutes) : 0;
                    const finalAvgSolve = questionsAnswered > 0
                        ? (game.totalMathSolveTime / questionsAnswered / 1000)
                        : 0;
                    primaryData = [finalSpm, finalSpm];
                    secondaryData = [finalAvgSolve, finalAvgSolve];
                }
            } else {
                // Start from actual performance history
                primaryData = game.wpmHistory.slice();
                secondaryData = game.accuracyHistory.slice();
                
                // If we don't have enough real data points yet, synthesize a flat line
                if (primaryData.length < 2 || secondaryData.length < 2) {
                    const totalTimeMinutes = (Date.now() - game.startTime) / 60000;
                    const finalWpm = totalTimeMinutes > 0
                        ? Math.round((game.correctCharacters / 5) / totalTimeMinutes)
                        : 0;
                    const totalAttempts = game.correctCharacters + game.incorrectAttempts;
                    const finalAccuracy = totalAttempts > 0
                        ? Math.round((game.correctCharacters / totalAttempts) * 100)
                        : 0;
                    
                    primaryData = [finalWpm, finalWpm];
                    secondaryData = [finalAccuracy, finalAccuracy];
                }
            }
            
            const points = primaryData.length;
            const padding = 0;
            const graphWidth = width - padding * 2;
            const graphHeight = height - 40; // Bottom padding for labels
            
            // Normalize values
            const MAX_WPM = 80;
            const MAX_SPS = 1.0;   // 1 solve per second is very fast
            const MAX_SOLVE_TIME = 15; // 15 seconds max solve time
            
            // Create paths for both lines
            const secondaryPath = [];
            const primaryPath = [];
            
            const exaggerate = (v) => {
                const exaggerated = 0.5 + (v - 0.5) * 2;
                return Math.max(0, Math.min(1, exaggerated));
            };
            
            for (let i = 0; i < points; i++) {
                const x = padding + (i / (points - 1)) * graphWidth;
                
                if (isMathGraph) {
                    // Secondary = solve time (green) - lower is better, so invert
                    let solveValue = Math.min(secondaryData[i] / MAX_SOLVE_TIME, 1);
                    solveValue = 1 - solveValue; // Invert so lower solve time = higher on graph
                    const secY = height - (solveValue * graphHeight);
                    secondaryPath.push({ x, y: secY });
                    
                    // Primary = SPS (yellow)
                    let spsValue = Math.min(primaryData[i] / MAX_SPS, 1);
                    spsValue = exaggerate(spsValue);
                    const primY = height - (spsValue * graphHeight);
                    primaryPath.push({ x, y: primY });
                } else {
                    // Secondary = accuracy (green)
                    let accValue = secondaryData[i] / 100;
                    const accY = height - (accValue * graphHeight);
                    secondaryPath.push({ x, y: accY });
                    
                    // Primary = WPM (yellow)
                    let wpmValue = Math.min(primaryData[i] / MAX_WPM, 1);
                    wpmValue = exaggerate(wpmValue);
                    const wpmY = height - (wpmValue * graphHeight);
                    primaryPath.push({ x, y: wpmY });
                }
            }
            
            // Animation setup
            const animationDuration = 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw secondary line (green) - back layer
                drawAnimatedPath(ctx, secondaryPath, progress, '#10b981', 'rgba(16, 185, 129, 0.7)', 'rgba(16, 185, 129, 0.2)', height);
                
                // Draw primary line (yellow) - front layer
                drawAnimatedPath(ctx, primaryPath, progress, '#FFD400', 'rgba(255, 212, 0, 0.5)', 'rgba(255, 212, 0, 0.1)', height);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function drawAnimatedPath(ctx, path, progress, strokeColor, fillTop, fillBottom, height) {
            if (path.length < 2) return;
            
            // Calculate total path length
            let totalLength = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i - 1].x;
                const dy = path[i].y - path[i - 1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            const targetLength = totalLength * progress;
            
            // Find points along the path up to targetLength
            let currentLength = 0;
            const visiblePath = [path[0]];
            
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i - 1].x;
                const dy = path[i].y - path[i - 1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                
                if (currentLength + segmentLength <= targetLength) {
                    visiblePath.push(path[i]);
                    currentLength += segmentLength;
                } else {
                    // Partial segment
                    const remaining = targetLength - currentLength;
                    const ratio = remaining / segmentLength;
                    const x = path[i - 1].x + dx * ratio;
                    const y = path[i - 1].y + dy * ratio;
                    visiblePath.push({ x, y });
                    break;
                }
            }
            
            if (visiblePath.length < 2) return;
            
            // Draw filled area
            ctx.beginPath();
            ctx.moveTo(visiblePath[0].x, height);
            visiblePath.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(visiblePath[visiblePath.length - 1].x, height);
            ctx.closePath();
            
            // Fill with gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, fillTop);
            gradient.addColorStop(1, fillBottom);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw stroke line
            ctx.beginPath();
            ctx.moveTo(visiblePath[0].x, visiblePath[0].y);
            for (let i = 1; i < visiblePath.length; i++) {
                ctx.lineTo(visiblePath[i].x, visiblePath[i].y);
            }
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        
        function togglePause() {
            game.isPaused = !game.isPaused;
            const icon = pauseBtn.querySelector('.material-symbols-outlined');
            if (icon) {
                icon.textContent = game.isPaused ? 'play_arrow' : 'pause';
            }
            
            // Show/hide pause overlay
            const pauseOverlay = document.getElementById('pauseOverlay');
            const pauseMicrocopy = document.getElementById('pauseMicrocopy');
            
            if (game.isPaused) {
                // Select random microcopy message
                const randomIndex = Math.floor(Math.random() * pauseMicrocopyMessages.length);
                pauseMicrocopy.textContent = pauseMicrocopyMessages[randomIndex];
                pauseOverlay.classList.add('show');
                ambientMusic.suspend();
            } else {
                pauseOverlay.classList.remove('show');
                ambientMusic.resume();
            }
        }

        // Apply difficulty settings (used when changing difficulty mid-game)
        function applyDifficultySettings(difficulty) {
            const difficultySettings = {
                'easy': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.3,
                    maxInvaders: 3
                },
                'medium': {
                    spawnInterval: 2000,
                    invaderSpeed: 0.3,
                    maxInvaders: 5
                },
                'hard': {
                    spawnInterval: 1500,
                    invaderSpeed: 0.3,
                    maxInvaders: 8
                }
            };
            
            const settings = difficultySettings[difficulty];
            game.difficulty = difficulty;
            game.spawnInterval = settings.spawnInterval;
            game.invaderSpeed = settings.invaderSpeed;
            game.maxInvaders = settings.maxInvaders;
        }

        // Event listeners
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        
        // Celebration top bar buttons
        document.getElementById('celebrationTopShareBtn').addEventListener('click', async () => {
            const statsText = `ðŸŽ® Type to Shoot Game Results ðŸŽ®

Score: ${game.score}
WPM: ${document.getElementById('celebrationWpm').textContent}
Accuracy: ${document.getElementById('celebrationAccuracy').textContent}
Rank: ${document.getElementById('playerRank').textContent}

Play now at: ${window.location.href}`;

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'Type to Shoot - My Results',
                        text: statsText
                    });
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.log('Share failed:', err);
                        copyToClipboard(statsText);
                    }
                }
            } else {
                copyToClipboard(statsText);
            }
        });
        
        document.getElementById('celebrationTopRestartBtn').addEventListener('click', () => {
            document.getElementById('celebrationScreen').style.display = 'none';
            startGame(game.mode);
        });

        // Journey tab switching
        document.querySelectorAll('.journey-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.dataset.tab;
                document.querySelectorAll('.journey-tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.journey-tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('jtab-' + tab).classList.add('active');
            });
        });

        document.getElementById('playAgainLink').addEventListener('click', () => {
            document.getElementById('celebrationScreen').style.display = 'none';
            startGame(game.mode);
        });

        document.getElementById('celebrationTopHomeBtn').addEventListener('click', () => {
            document.getElementById('celebrationScreen').style.display = 'none';
            gameContainer.classList.add('hidden');
            topbar.classList.remove('show');
            timeSelection.classList.remove('hidden');
            
            // Clear invaders and bullets
            game.invaders.forEach(z => z.element && z.element.remove());
            game.bullets.forEach(b => b.remove());
            game.invaders = [];
            game.bullets = [];
        });

        document.getElementById('celebrationShuffleBtn').addEventListener('click', () => {
            if (game.mode === 'journey') {
                // Generate fake journey stats for testing
                game.score     = 1000;
                game.startTime = Date.now() - (Math.random() * 15 + 3) * 60 * 1000;
                game.journeyStats = {
                    words:     {
                        wordsHit:     Math.floor(Math.random() * 80 + 20),
                        wordsMissed:  Math.floor(Math.random() * 15),
                        incorrectKeys: Math.floor(Math.random() * 40),
                        correctChars: Math.floor(Math.random() * 400 + 100)
                    },
                    sentences: {
                        completed:    Math.floor(Math.random() * 10 + 2),
                        skipped:      Math.floor(Math.random() * 5),
                        incorrectKeys: Math.floor(Math.random() * 30)
                    },
                    math:      {
                        solved:       Math.floor(Math.random() * 30 + 5),
                        missed:       Math.floor(Math.random() * 10),
                        fastSolves:   Math.floor(Math.random() * 10),
                        totalSolveTime: Math.floor(Math.random() * 60000 + 10000)
                    },
                    letters:   {
                        hit:    Math.floor(Math.random() * 50 + 10),
                        missed: Math.floor(Math.random() * 15)
                    }
                };
            } else {
                const modes = ['words', 'sentences', 'math'];
                game.mode = modes[Math.floor(Math.random() * modes.length)];
                game._mathGraphMode = game.mode === 'math';
                game.score        = 1000 + Math.floor(Math.random() * 4000);
                game.startTime    = Date.now() - (Math.random() * 20 + 2) * 60 * 1000;
                const totalMins   = (Date.now() - game.startTime) / 60000;
                game.correctCharacters  = Math.floor(Math.random() * 80 * totalMins * 5 + 100);
                game.incorrectAttempts  = Math.floor(Math.random() * game.correctCharacters * 0.15);
                game.missedWords        = Math.floor(Math.random() * 30);
                const samples = 20 + Math.floor(Math.random() * 20);
                game.wpmHistory      = Array.from({ length: samples }, (_, i) => Math.max(5, 30 + Math.random() * 120 + Math.sin(i / 3) * 20));
                game.accuracyHistory = Array.from({ length: samples }, (_, i) => Math.min(100, Math.max(50, 70 + Math.random() * 30 - Math.cos(i / 4) * 10)));
                game.spmHistory      = Array.from({ length: samples }, () => +(Math.random() * 3).toFixed(2));
                game.solveTimeHistory= Array.from({ length: samples }, () => +(1 + Math.random() * 9).toFixed(1));
                game.mathQuestionsAnswered = Math.floor(Math.random() * 80 + 10);
                game.totalMathSolveTime    = game.mathQuestionsAnswered * (1 + Math.random() * 5) * 1000;
            }
            showCelebration();
        });
        
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Failed to copy results');
            }
            document.body.removeChild(textArea);
        }
        
        // Restart button during game - restarts immediately with same difficulty
        restartGameBtn.addEventListener('click', () => {
            const currentMode = game.mode;
            // fullCleanup is called inside startGame, but capture mode first
            startGame(currentMode);
        });
        
        // Home button - return to main menu
        const homeBtn = document.getElementById('homeBtn');
        homeBtn.addEventListener('click', () => {
            fullCleanup();
            ambientMusic.stop();
            game.completedChallenges = [];

            // Hide game container and show time selection
            gameContainer.classList.add('hidden');
            topbar.classList.remove('show');
            timeSelection.classList.remove('hidden');
        });
        
        // difficultyDisplay is read-only - shows current mode name, not clickable
        
        // Category cycling (categoryDisplay removed from UI, kept for internal state)
        // categoryDisplay.addEventListener removed
        
        // Mode option selection on start screen - starts game immediately
        const difficultyOptions = document.querySelectorAll('.difficulty-option');
        difficultyOptions.forEach(option => {
            option.addEventListener('click', () => {
                const mode = option.getAttribute('data-mode');
                const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
                // Focus mobile input immediately on user interaction (mobile only)
                if (isMobile) {
                    mobileInput.focus();
                }
                // Small delay to ensure focus has taken effect
                setTimeout(() => {
                    startGame(mode);
                }, 50);
            });
        });
        
        // Click anywhere on game to refocus mobile input (for mobile keyboard)
        // Click on game area to pause/unpause
        gameContainer.addEventListener('click', (e) => {
            // Don't trigger pause if clicking on buttons, keyboard, or topbar
            if (e.target.closest('#pauseBtn, #restartGameBtn, #homeBtn, #celebrationPreviewBtn, .key, #onScreenKeyboard, #topbar')) {
                return;
            }
            
            const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
            
            if (!game.isGameOver) {
                // Toggle pause on click/tap
                togglePause();
            }
            
            // Also refocus mobile input if not paused
            if (!game.isGameOver && !game.isPaused && isMobile) {
                mobileInput.focus();
            }
        });
        
        // Pause overlay click to unpause
        const pauseOverlay = document.getElementById('pauseOverlay');
        pauseOverlay.addEventListener('click', () => {
            if (game.isPaused && !game.isGameOver) {
                togglePause();
            }
        });
        
        // On-screen keyboard handler - MOBILE OPTIMIZED
        const keyboardKeys = document.querySelectorAll('.key');
        
        keyboardKeys.forEach(key => {
            // Visual feedback on touch
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                key.classList.add('pressed');
            }, { passive: false });
            
            // Use touchend for better mobile responsiveness
            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove visual feedback
                setTimeout(() => key.classList.remove('pressed'), 100);
                
                if (game.isGameOver || game.isPaused) {
                    return;
                }
                
                const keyValue = key.getAttribute('data-key');
                
                // Directly handle the key press
                handleKeyPress(keyValue);
            }, { passive: false });
            
            // Also keep click for desktop testing
            key.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Visual feedback
                key.classList.add('pressed');
                setTimeout(() => key.classList.remove('pressed'), 100);
                
                if (game.isGameOver || game.isPaused) return;
                
                const keyValue = key.getAttribute('data-key');
                handleKeyPress(keyValue);
            });
        });
        
        // Function to update keyboard key highlighting
        function updateKeyboardHighlight() {
            const keyboardKeys = document.querySelectorAll('.key');
            
            // Clear all active highlights first
            keyboardKeys.forEach(k => k.classList.remove('active'));
            
            // Highlight keys that were typed correctly
            if (game.currentInput && game.targetInvader && !game.targetInvader.isDying) {
                for (let i = 0; i < game.currentInput.length; i++) {
                    const char = game.currentInput[i];
                    keyboardKeys.forEach(k => {
                        if (k.getAttribute('data-key') === char) {
                            k.classList.add('active');
                        }
                    });
                }
            }
        }

        // â”€â”€ Shared math key handler (desktop keydown + mobile number pad) â”€â”€â”€â”€â”€â”€â”€â”€
        function _handleMathKey(digit) {
            const newInput = game.currentInput + digit;
            game.totalCharactersTyped++;
            if (!game.wordStartTime) game.wordStartTime = Date.now();

            // Exact match â†’ auto-shoot immediately
            const mathInvader = game.invaders.find(z => !z.isDying && z.word === newInput);
            if (mathInvader) {
                playSuccessSound();
                mathInvader.wordElement.classList.add('typing');
                mathInvader.wordElement.style.setProperty('--progress', '110%');
                mathInvader.isDying = true;
                const travelTime = shoot(mathInvader);
                setTimeout(() => {
                    mathInvader.element.classList.add('dying');
                    setTimeout(() => { mathInvader.element.remove(); }, 500);
                }, travelTime);
                updateScore(mathInvader.word, mathInvader);
                if (mathInvader.isMathQuestion) {
                    if (game.mathQuestionStartTime) {
                        game.totalMathSolveTime += Date.now() - game.mathQuestionStartTime;
                        game.mathQuestionsAnswered++;
                        game.mathQuestionStartTime = null;
                    }
                    const _sid = _sessionId;
                    setTimeout(() => {
                        if (_sessionId !== _sid || game.isGameOver) return;
                        spawnMathInvader();
                    }, travelTime + 500);
                }
                game.currentInput = '';
                mobileInput.value = '';
                game.targetInvader = null;
                game.wordStartTime = null;
                rotateRocketToTarget(null);
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
                return;
            }

            // Accumulate digit
            game.currentInput = newInput;
            mobileInput.value = newInput;

            // If typed as many digits as the answer length â†’ wrong answer, reset
            const activeInvader = game.invaders.find(z => !z.isDying && z.isMathQuestion);
            if (activeInvader && newInput.length >= activeInvader.word.length) {
                game.incorrectAttempts++;
                resetCombo();
                playErrorSound();
                game.currentInput = '';
                mobileInput.value = '';
                game.wordStartTime = null;
            }

            // Aim rocket at active math invader
            const aimTarget = game.invaders.find(z => !z.isDying);
            game.targetInvader = aimTarget || null;
            rotateRocketToTarget(game.targetInvader);
            updateWordProgress();
            updateInputDisplay();
            updateKeyboardHighlight();
        }

        // â”€â”€ Shared word/letter key handler (desktop keydown + mobile keyboard) â”€
        function _handleWordKey(char) {
            const newInput = game.currentInput + char;
            game.totalCharactersTyped++;

            // Prefix check
            const hasMatch = game.invaders.some(inv => !inv.isDying && inv.word.startsWith(newInput));

            if (!hasMatch) {
                game.incorrectAttempts++;
                resetCombo();
                playErrorSound();
                game.currentInput = '';
                mobileInput.value = '';
                game.targetInvader = null;
                rotateRocketToTarget(null);
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
                game.invaders.forEach(z => {
                    if (!z.isDying && z.wordElement) z.wordElement.classList.remove('typing');
                });
                return;
            }

            // Correct character
            game.correctCharacters++;
            if (!game.wordStartTime) game.wordStartTime = Date.now();
            game.currentInput = newInput;
            mobileInput.value = newInput;

            // Exact match â†’ shoot
            const matchedInvader = game.invaders.find(z => !z.isDying && z.word === newInput);
            if (matchedInvader) {
                if (game.wordStartTime) {
                    const wt = Date.now() - game.wordStartTime;
                    if (!game.fastestWordTime || wt < game.fastestWordTime) game.fastestWordTime = wt;
                    game.wordStartTime = null;
                }
                playSuccessSound();
                matchedInvader.wordElement.classList.add('typing');
                matchedInvader.wordElement.style.setProperty('--progress', '110%');
                matchedInvader.isDying = true;
                const travelTime = shoot(matchedInvader);
                setTimeout(() => {
                    matchedInvader.element.classList.add('dying');
                    setTimeout(() => { matchedInvader.element.remove(); }, 500);
                }, travelTime);
                updateScore(matchedInvader.word, matchedInvader);
                game.currentInput = '';
                mobileInput.value = '';
                game.targetInvader = null;
                rotateRocketToTarget(null);
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
                game.invaders.forEach(z => {
                    if (!z.isDying && z.wordElement) z.wordElement.classList.remove('typing');
                });
                return;
            }

            // Partial match â€” update target tracking
            let targetInvader = null;
            game.invaders.forEach(invader => {
                if (invader.isDying || !invader.wordElement) return;
                if (!targetInvader && invader.word.startsWith(newInput)) targetInvader = invader;
                invader.wordElement.classList.remove('typing');
            });
            game.targetInvader = targetInvader;
            rotateRocketToTarget(targetInvader);
            updateWordProgress();
            updateInputDisplay();
            updateKeyboardHighlight();
        }

        // Function to handle key presses (for both keyboard and on-screen keyboard)
        function handleKeyPress(keyValue) {
            if (game.isGameOver || game.isPaused) return;

            const _mode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
            const _isMath = _mode === 'math' || game.isMathMode;

            // Sentences mode: route all keys through handleSentenceInput
            if (_mode === 'sentences' && game.isSentenceActive) {
                handleSentenceInput({ key: keyValue });
                return;
            }

            if (keyValue === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
                mobileInput.value = game.currentInput;
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();

            } else if (_isMath && /^[0-9]$/.test(keyValue)) {
                _handleMathKey(keyValue);

            } else if (!_isMath && keyValue.length === 1) {
                _handleWordKey(keyValue.toLowerCase());
            }
        }

        // Auto-Test Mode
        let autoTestEnabled = false;
        let autoTestInterval = null;
        let speedRoundChecker = null;
        let lastScore = 0;
        
        const autoTestToggle = document.getElementById('autoTestToggle');
        
        autoTestToggle.addEventListener('click', () => {
            autoTestEnabled = !autoTestEnabled;
            
            if (autoTestEnabled) {
                autoTestToggle.style.background = '#10b981';
                autoTestToggle.innerHTML = '<span style="font-size: 14px;">ðŸ¤– ON</span>';
                startAutoTest();
            } else {
                autoTestToggle.style.background = '#3b82f6';
                autoTestToggle.innerHTML = '<span style="font-size: 14px;">ðŸ¤– TEST</span>';
                stopAutoTest();
            }
        });
        
        // Celebration preview button for testing
        const celebrationPreviewBtn = document.getElementById('celebrationPreviewBtn');
        celebrationPreviewBtn.addEventListener('click', () => {
            // Toggle celebration screen
            const celebrationScreen = document.getElementById('celebrationScreen');
            if (celebrationScreen.style.display === 'flex') {
                celebrationScreen.style.display = 'none';
                // Show default top bar again
                document.getElementById('topbar').classList.add('show');
                // Show keyboard again on mobile if it was hidden
                const isMobile = (window.matchMedia("(max-width: 1024px)").matches || window.matchMedia("(pointer: coarse)").matches);
                if (isMobile && !game.isMathMode) {
                    document.getElementById('onScreenKeyboard').style.display = 'flex';
                }
            } else {
                // Set some sample data for preview
                game.score = Math.floor(Math.random() * 1000);
                game.startTime = Date.now() - (5 * 60 * 1000); // 5 minutes ago
                game.correctCharacters = 250 + Math.floor(Math.random() * 200);
                game.incorrectAttempts = Math.floor(Math.random() * 50);
                game.missedWords = Math.floor(Math.random() * 30);
                
                showCelebration();
            }
        });

        // Game topbar shuffle button â€” journey mode only, generates fake stats & shows celebration
        document.getElementById('gameShuffleBtn').addEventListener('click', () => {
            game.score     = 1000;
            game.startTime = Date.now() - (Math.random() * 15 + 3) * 60 * 1000;
            game.journeyStats = {
                words:     { wordsHit: Math.floor(Math.random() * 80 + 20), wordsMissed: Math.floor(Math.random() * 15), incorrectKeys: Math.floor(Math.random() * 40), correctChars: Math.floor(Math.random() * 400 + 100) },
                sentences: { completed: Math.floor(Math.random() * 10 + 2), skipped: Math.floor(Math.random() * 5), incorrectKeys: Math.floor(Math.random() * 30) },
                math:      { solved: Math.floor(Math.random() * 30 + 5), missed: Math.floor(Math.random() * 10), fastSolves: Math.floor(Math.random() * 10), totalSolveTime: Math.floor(Math.random() * 60000 + 10000) },
                letters:   { hit: Math.floor(Math.random() * 50 + 10), missed: Math.floor(Math.random() * 15) }
            };
            showCelebration();
        });
        
        function startAutoTest() {
            console.log('ðŸ¤– Auto-Test Mode ENABLED');
            console.log('ðŸ“‹ Test Plan:');
            console.log('  0-199: Normal Mode (words)');
            console.log('  200: Speed Round 1');
            console.log('  300: Speed Round 2');
            console.log('  400: Speed Round 3');
            console.log('  500: Speed Round 4');
            console.log('  600: Speed Round 5');
            console.log('  700: Speed Round 6');
            console.log('  800+: Math Mode');
            console.log('  900+: Letter Mode');
            
            // Auto-start game if not started
            if (!game.isGameOver && gameContainer.classList.contains('hidden')) {
                startGame('words');
            }
            
            // Monitor score changes and log mode transitions
            speedRoundChecker = setInterval(() => {
                if (game.score !== lastScore) {
                    lastScore = game.score;
                    
                    // Log mode transitions
                    if (game.score === 200 || game.score === 300 || game.score === 400 || 
                        game.score === 500 || game.score === 600 || game.score === 700) {
                        console.log(`ðŸŽ¯ Score ${game.score} - Speed Round triggered!`);
                    } else if (game.score === 800) {
                        console.log('ðŸ§® Score 800 - Math Mode activated!');
                    } else if (game.score === 900) {
                        console.log('â­ Score 900 - Letter Mode activated!');
                    }
                }
                
                // Auto-complete Speed Rounds
                if (game.isChallenge) {
                    const challengeSentence = document.getElementById('challengeSentence');
                    if (challengeSentence) {
                        const targetSentence = challengeSentence.textContent;
                        const remaining = targetSentence.slice(game.currentInput.length);
                        
                        if (remaining.length > 0) {
                            const char = remaining[0];
                            const event = new KeyboardEvent('keydown', {
                                key: char,
                                code: char === ' ' ? 'Space' : `Key${char.toUpperCase()}`,
                                bubbles: true
                            });
                            document.dispatchEvent(event);
                        }
                    }
                }
            }, 100);
            
            // Auto-play the game
            autoTestInterval = setInterval(() => {
                if (game.isGameOver) {
                    console.log('âŒ Game Over - Auto-test completed');
                    stopAutoTest();
                    return;
                }
                
                if (game.isPaused || game.isChallenge) return;
                
                // Handle sentences mode auto-typing (direct sentences mode OR journey sentences phase)
                const autoCurrentMode = game.mode === 'journey' ? getJourneyPhaseMode() : game.mode;
                if (autoCurrentMode === 'sentences' && game.isSentenceActive && game.currentSentenceText) {
                    const targetSentence = game.currentSentenceText;
                    const remaining = targetSentence.slice(game.currentInput.length);
                    if (remaining.length > 0) {
                        const char = remaining[0];
                        const event = new KeyboardEvent('keydown', {
                            key: char,
                            code: char === ' ' ? 'Space' : `Key${char.toUpperCase()}`,
                            bubbles: true
                        });
                        document.dispatchEvent(event);
                    }
                    return;
                }
                
                // Find a target invader
                const activeInvaders = game.invaders.filter(inv => !inv.isDying);
                
                if (activeInvaders.length > 0 && game.currentInput === '') {
                    // Pick the invader closest to the bottom (most urgent)
                    const target = activeInvaders.reduce((lowest, inv) => 
                        inv.y > lowest.y ? inv : lowest
                    );
                    
                    // Type the word/answer automatically
                    const word = target.word;
                    
                    console.log(`ðŸŽ¯ Targeting: "${word}" (${target.emoji})`);
                    
                    // Type all characters quickly
                    for (let i = 0; i < word.length; i++) {
                        setTimeout(() => {
                            const char = word[i];
                            const event = new KeyboardEvent('keydown', {
                                key: char,
                                code: char === ' ' ? 'Space' : `Key${char.toUpperCase()}`,
                                bubbles: true
                            });
                            document.dispatchEvent(event);
                        }, i * 30); // 30ms between characters
                    }
                }
            }, 100); // faster polling for sentences mode
        }
        
        function stopAutoTest() {
            console.log('ðŸ¤– Auto-Test Mode DISABLED');
            if (autoTestInterval) {
                clearInterval(autoTestInterval);
                autoTestInterval = null;
            }
            if (speedRoundChecker) {
                clearInterval(speedRoundChecker);
                speedRoundChecker = null;
            }
            lastScore = 0;
        }

        // Floating words background animation
        // Handle window resize to keep invaders in bounds
        window.addEventListener('resize', () => {
            game.invaders.forEach(invader => {
                if (!invader.isDying && invader.element) {
                    const elementWidth = invader.element.offsetWidth || 100;
                    
                    // Adjust position if out of bounds
                    if (invader.x < 0) {
                        invader.x = 0;
                    } else if (invader.x + elementWidth > window.innerWidth) {
                        invader.x = window.innerWidth - elementWidth;
                    }
                    
                    // Update element position
                    invader.element.style.left = invader.x + 'px';
                }
            });
        });

        // Initialize game - show start screen
        // Game starts when user clicks start button

        // Ensure Material Symbols font is loaded before showing icons
        (function() {
            function markIconsLoaded() {
                document.body.classList.add('icons-loaded');
            }
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(markIconsLoaded);
            } else {
                // Fallback: mark loaded after short delay
                setTimeout(markIconsLoaded, 500);
            }
            // Also force-show after 3s no matter what
            setTimeout(markIconsLoaded, 3000);
        })();
    </script>
</body>
</html>
