<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Word Shooter</title>
    
    <!-- Open Graph -->
    <meta property="og:title" content="ðŸš€ Word Shooter">
    <meta property="og:image" content="https://wordshooter.vercel.app/og-image.png">
    <meta property="og:url" content="https://wordshooter.vercel.app/">
    <meta property="og:type" content="website">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ðŸš€ Word Shooter">
    <meta name="twitter:image" content="https://wordshooter.vercel.app/og-image.png">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸš€</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
            overscroll-behavior: none;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            color: white;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            -webkit-overflow-scrolling: touch;
            touch-action: none;
            overscroll-behavior: none;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(1px 1px at 15% 55%, white, transparent),
                radial-gradient(2px 2px at 70% 25%, white, transparent),
                radial-gradient(1px 1px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 25% 90%, white, transparent);
            background-size: 200% 200%, 300% 300%, 250% 250%, 280% 280%, 220% 220%, 
                             260% 260%, 290% 290%, 240% 240%, 270% 270%, 230% 230%;
            background-position: 0% 0%, 40% 60%, 50% 50%, 80% 10%, 90% 60%, 
                                 33% 80%, 15% 55%, 70% 25%, 45% 15%, 25% 90%;
            background-repeat: repeat;
            opacity: 0.6;
            z-index: 0;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Use dynamic viewport height for mobile browsers */
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            z-index: 1;
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            overflow: hidden;
            touch-action: none;
            /* Safe area insets for notched devices */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        #gameContainer::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(1px 1px at 15% 55%, white, transparent),
                radial-gradient(2px 2px at 70% 25%, white, transparent),
                radial-gradient(1px 1px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 25% 90%, white, transparent);
            background-size: 200% 200%, 300% 300%, 250% 250%, 280% 280%, 220% 220%, 
                             260% 260%, 290% 290%, 240% 240%, 270% 270%, 230% 230%;
            background-position: 0% 0%, 40% 60%, 50% 50%, 80% 10%, 90% 60%, 
                                 33% 80%, 15% 55%, 70% 25%, 45% 15%, 25% 90%;
            background-repeat: repeat;
            opacity: 0.6;
            z-index: 0;
        }

        #gameContainer.hidden {
            display: none;
        }

        /* Top side - Invader area */
        #topSide {
            width: 100%;
            height: 70%;
            position: relative;
            background: linear-gradient(to bottom, #16213e, transparent);
        }

        /* Bottom side - Spaceship area */
        #bottomSide {
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, #0f3460, transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 500;
        }
        
        /* Create a mask to hide lasers below the rocket */
        #bottomSide::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, 
                radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%) 0%, 
                transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        #gun {
            font-size: 80px;
            transform: rotate(-45deg);
            transition: transform 0.3s ease;
            position: relative;
            z-index: 510;
        }

        #gun.shoot {
            transform: rotate(-45deg) scale(1.2);
        }

        #gun.aiming {
            transition: transform 0.3s ease;
        }

        #inputDisplay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) scale(0.85);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px 30px;
            font-size: 24px;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            letter-spacing: 2px;
            transition: all 0.3s ease;
            transform-origin: center;
            /* Show by default on desktop */
            opacity: 1;
            visibility: visible;
            z-index: 510;
        }
        
        /* Hide when empty (no content) */
        #inputDisplay:empty {
            opacity: 0;
            visibility: hidden;
        }

        #inputDisplay.active {
            transform: translateX(-50%) scale(1);
            min-width: 300px;
        }

        #inputDisplay .typed {
            color: white;
            opacity: 1;
        }

        #inputDisplay .untyped {
            color: white;
            opacity: 0.3;
        }

        #inputDisplay.error {
            animation: inputShake 0.3s;
            border-color: rgba(255, 68, 68, 0.6);
            background: rgba(255, 68, 68, 0.1);
        }

        @keyframes inputShake {
            0%, 100% { transform: translateX(-50%) scale(1); }
            25% { transform: translateX(calc(-50% - 5px)) scale(1); }
            75% { transform: translateX(calc(-50% + 5px)) scale(1); }
        }

        /* Hidden mobile input for keyboard */
        #mobileInput {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            opacity: 0.01;
            z-index: 9999;
            border: none;
            background: transparent;
            color: transparent;
            font-size: 16px;
            caret-color: transparent;
            pointer-events: auto;
        }
        
        #mobileInput:focus {
            outline: none;
        }
        
        /* On-screen keyboard - HIDDEN ON DESKTOP */
        #onScreenKeyboard {
            display: none;
            flex-direction: column;
            gap: 0;  /* Remove gap between rows */
            padding: 0;  /* Remove all padding */
            background: transparent;  /* Remove dark background */
            border-radius: 0;  /* Remove border radius */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 510;
        }
        
        /* Hide normal keyboard during challenge */
        #onScreenKeyboard.hide-for-challenge {
            display: none !important;
        }
        
        /* Number keyboard for math mode */
        #numberKeyboard {
            display: none;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: transparent;
            border-radius: 0;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 510;
        }
        
        #numberKeyboard.show {
            display: flex;
        }
        
        #numberKeyboard .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 0;
        }
        
        #numberKeyboard .key {
            width: calc(100% / 5);  /* 5 keys per row */
            height: 52px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            border-right: 0.5px solid rgba(255, 255, 255, 0.1);
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
        }
        
        #numberKeyboard .key:active {
            background: rgba(16, 185, 129, 0.5);
            transform: scale(0.95);
        }
        
        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 0;  /* No gap - keys will be sized by media queries */
        }
        
        .key {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .key:active {
            background: rgba(16, 185, 129, 0.5);
            transform: scale(0.95);
        }
        
        .key.pressed {
            background: rgba(255, 215, 0, 0.7) !important;
            border-color: rgba(255, 215, 0, 1) !important;
        }
        
        .key.active {
            background: rgba(22, 160, 133, 0.7) !important;
            border-color: rgba(22, 160, 133, 1) !important;
        }
        
        /* Show keyboard ONLY on mobile */
        @media (max-width: 768px) {
            #onScreenKeyboard {
                display: flex;
                gap: 0;  /* Remove gap between rows */
                padding: 0;  /* Remove all padding - attach to bottom */
            }
            
            #numberKeyboard {
                /* Keep hidden by default, shown when math mode activates */
            }
            
            #mobileInput {
                display: none;
            }
            
            #inputDisplay {
                bottom: 230px;
                /* Always hide on mobile/tablet since we show keyboard */
                display: none !important;
            }
            
            .keyboard-row {
                gap: 0;  /* Remove gap between keys */
            }
            
            .key {
                width: calc(100% / 10);  /* 10 keys in first row - equal width */
                height: 52px;  /* Increased height */
                font-size: 18px;
                border-radius: 0;  /* Remove border radius for seamless look */
                border-right: 0.5px solid rgba(255, 255, 255, 0.1);  /* Subtle separator */
                border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            }
            
            .keyboard-row:first-child .key {
                width: calc(100% / 10);  /* 10 keys */
            }
            
            .keyboard-row:nth-child(2) .key {
                width: calc(100% / 9);  /* 9 keys */
            }
            
            .keyboard-row:nth-child(3) .key {
                width: calc(100% / 9);  /* 9 keys (7 letters + 2 buttons) */
            }
        }
        
        @media (max-width: 480px) {
            .key {
                height: 50px;  /* Slightly smaller for small screens */
                font-size: 16px;
            }
            
            #onScreenKeyboard {
                gap: 0;
                padding: 8px 0;
            }
            
            #inputDisplay {
                bottom: 210px;
            }
            
            #gun {
                font-size: 40px;
                margin-bottom: 160px;
            }
        }
        
        @media (max-width: 375px) {
            .key {
                height: 48px;  /* Slightly smaller for very small screens */
                font-size: 14px;
            }
            
            #onScreenKeyboard {
                gap: 0;
                padding: 8px 0;
            }
            
            #inputDisplay {
                bottom: 200px;
            }
        }

        /* Invader styling */
        .invader {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .invader-emoji {
            font-size: 40px;
            margin-bottom: 5px;
        }

        .invader-word {
            background: rgba(255, 255, 255, 0.8);
            color: #16213e;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            --progress: 0%;
        }

        .invader-word::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--progress);
            background: rgba(16, 185, 129, 0.8);
            transition: width 0.1s ease;
            z-index: 0;
            border-radius: 15px;
        }

        .invader-word .char {
            position: relative;
            z-index: 1;
        }

        .invader-word.typing {
            background: rgba(16, 185, 129, 0.8) !important;
            color: white;
        }

        .invader-word.typing::before {
            width: 110% !important;  /* Extend beyond 100% to ensure full coverage */
            transition: none;  /* Remove transition delay on completion */
        }

        .invader.dying {
            animation: die 0.5s forwards;
        }
        
        /* Keep green color when matched invader is dying - HIGH SPECIFICITY */
        .invader.dying .invader-word.typing {
            background: rgba(16, 185, 129, 0.8) !important;
            color: white !important;
        }
        
        /* Also ensure emoji container doesn't interfere */
        .invader.dying .invader-emoji {
            opacity: 1;
        }
        
        /* Hide the progress ::before element when completed to show solid green background */
        .invader.dying .invader-word.typing::before,
        .invader-word.typing::before {
            display: none !important;
        }
        
        /* Ensure the green stays during the entire fade animation */
        @keyframes die {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        /* Force green to persist on dying invaders with typing class */
        .invader.dying > .invader-word.typing {
            background-color: rgba(16, 185, 129, 0.8) !important;
        }

        /* Bullet styling */
        .bullet {
            position: absolute;
            width: 3px;
            height: 0px;
            background: linear-gradient(to bottom, 
                rgba(255, 50, 50, 1) 0%,
                rgba(255, 100, 100, 0.9) 50%,
                rgba(255, 50, 50, 1) 100%);
            box-shadow: 
                0 0 10px rgba(255, 50, 50, 0.8),
                0 0 20px rgba(255, 50, 50, 0.6),
                0 0 30px rgba(255, 50, 50, 0.4);
            z-index: 100;
            transform-origin: top center;
            pointer-events: none;
        }
        
        .bullet::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, 
                rgba(255, 255, 255, 1) 0%,
                rgba(255, 100, 100, 1) 40%,
                rgba(255, 50, 50, 0.8) 70%,
                transparent 100%);
            border-radius: 50%;
            box-shadow: 
                0 0 15px rgba(255, 50, 50, 1),
                0 0 25px rgba(255, 50, 50, 0.8);
        }

        /* Topbar Container */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;  /* Reduced from 20px to match tablet */
            z-index: 1000;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        #topbar.show {
            display: flex;
        }

        #leftControls {
            display: flex;
            gap: 7.5px;  /* Reduced by half (was 15px) */
            align-items: center;
        }

        #rightControls {
            display: flex;
            gap: 7.5px;  /* Reduced by half (was 15px) */
            align-items: center;
        }

        /* UI Elements */
        #score {
            font-size: 12px;  /* Reduced from 20px to match tablet */
            font-weight: bold;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            padding: 6px 10px;  /* Reduced from 8px 16px to match tablet */
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
            height: 32px;  /* Reduced from 40px to match tablet */
        }

        #scoreValue {
            position: relative;
            display: inline-block;
            transition: color 0.3s ease;
        }

        #scoreValue.score-increase {
            animation: scoreUp 0.5s ease-out;
        }

        #scoreValue.score-decrease {
            animation: scoreDown 0.5s ease-out;
            color: #ff4444;
        }

        @keyframes scoreUp {
            0% {
                transform: scale(1.3);
                opacity: 0.7;
                color: #4ecca3;
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                color: inherit;
            }
        }

        @keyframes scoreDown {
            0% {
                transform: scale(1.3);
                opacity: 0.7;
                color: #ff4444;
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                color: #ff4444;
            }
        }

        #difficultyDisplay {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            padding: 6px 10px;  /* Reduced from 8px 16px to match tablet */
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 20px to match tablet */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #difficultyDisplay:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #categoryDisplay {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            padding: 6px 10px;  /* Reduced from 8px 16px to match tablet */
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 20px to match tablet */
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #categoryDisplay:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #pauseBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;  /* Reduced from 40px to match tablet */
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 16px to match tablet */
            font-weight: bold;
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pauseBtn .material-symbols-outlined {
            font-size: 18px;  /* Increased to 18px (was 16px) */
            line-height: 1;
        }

        #pauseBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #restartGameBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;  /* Reduced from 40px to match tablet */
            height: 32px;  /* Reduced from 40px to match tablet */
            font-size: 12px;  /* Reduced from 16px to match tablet */
            font-weight: bold;
            border-radius: 10px;  /* Reduced by 2px (was 12px) */
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #restartGameBtn .material-symbols-outlined {
            font-size: 18px;  /* Increased to 18px (was 16px) */
            line-height: 1;
        }

        #restartGameBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        #homeBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #homeBtn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
        }

        #homeBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Game Over Screen */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile */
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow: hidden;
        }

        #gameOver.show {
            display: flex;
        }

        #gameOver h1 {
            font-size: 72px;
            margin-bottom: 20px;
            color: #ff4757;
            text-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
        }

        #finalScore {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #restartBtn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            font-family: 'Press Start 2P', cursive;
        }

        #restartBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Celebration Screen */
        #celebrationScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overflow-y: auto;
            padding: 20px;
            pointer-events: auto;
        }

        #celebrationTopBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            z-index: 3001;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            pointer-events: auto;
            gap: 7.5px;
        }
        
        #celebrationTopBar .celebration-title {
            font-size: 16px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(135deg, #ff8c00 0%, #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #celebrationTopBar .celebration-buttons {
            display: flex;
            gap: 7.5px;
        }

        .celebration-top-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .celebration-top-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .celebration-top-btn .material-symbols-outlined {
            font-size: 18px;
            line-height: 1;
        }

        #celebrationCard {
            background: rgba(30, 45, 70, 0.98);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 19px;
            width: 300px;
            height: 424px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }
        
        /* 3D Hover Effect */
        .hover-3d-wrapper {
            perspective: 1000px;
            display: inline-block;
        }
        
        .hover-3d {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease-out;
            will-change: transform;
        }
        
        /* Hide the 8 effect divs - they create color overlays */
        .hover-3d > div:not(#celebrationCard) {
            display: none;
        }

        #celebrationHeader {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .header-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .header-rank {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .header-value {
            font-size: 36px;
            color: #ffd700;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            line-height: 1;
        }

        #celebrationBody {
            padding: 16px 20px 20px 20px;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .left-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stat-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .stat-value {
            font-size: 32px;
            color: #ffd700;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            line-height: 1;
        }

        #celebrationBody #rocketIcon {
            position: absolute;
            right: 20px;
            top: 32px;
            font-size: 56px;
            opacity: 0.95;
            animation: rocketFloat 3s ease-in-out infinite;
        }

        @keyframes rocketFloat {
            0%, 100% { transform: translateY(0) rotate(-25deg); }
            50% { transform: translateY(-12px) rotate(-25deg); }
        }

        .bottom-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: flex-start;
            padding: 0 0px;
        }

        .bottom-stats-left,
        .bottom-stats-right {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bottom-stats-right {
            text-align: right;
        }

        .bottom-stat-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .bottom-stat-value {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .graph-container {
            margin-top: 8px;
        }

        #performanceGraph {
            width: 100%;
            height: 150px;
            display: block;
        }

        .graph-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0px 0 0px;
        }

        .graph-time-label {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Press Start 2P', cursive;
            line-height: 1.2;
        }

        .graph-time-label.center {
            flex: 1;
            text-align: center;
        }

        @media (max-width: 768px) {
            #celebrationCard {
                width: 280px;
                height: 404px;
            }

            .header-label,
            .header-rank {
                font-size: 11px;
            }

            .header-value {
                font-size: 32px;
            }

            .stat-label {
                font-size: 9px;
            }

            .stat-value {
                font-size: 28px;
            }

            #celebrationBody #rocketIcon {
                font-size: 48px;
                right: 18px;
                top: 28px;
            }

            #performanceGraph {
                height: 130px;
            }

            .bottom-stat-label,
            .bottom-stat-value {
                font-size: 9px;
            }
            
            .celebration-top-btn {
                width: 28px;
                height: 28px;
            }
            
            .celebration-top-btn .material-symbols-outlined {
                font-size: 16px;
            }
        }

        /* Pause Overlay */
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            cursor: pointer;
        }

        #pauseOverlay.show {
            display: flex;
        }

        #pauseContent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #pauseMicrocopy {
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #pauseIcon {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 20px;  /* Changed to accommodate text */
            border-radius: 10px;
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        #pauseIcon:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        #pauseIcon .material-symbols-outlined {
            font-size: 23px;  /* 30% bigger than 18px */
            line-height: 1;
        }
        
        #pauseIcon .pause-text {
            font-size: 16px;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive;
        }

        /* Challenge Screen */
        #challengeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: rgba(0, 0, 0, 0.5);  /* 50% black instead of 95% */
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        #challengeScreen.show {
            display: flex;
        }

        #challengeContent {
            text-align: center;
            max-width: 90%;
            padding: 40px;
        }

        #challengeTimer {
            font-size: 28px;  /* Same size as title */
            color: #ff4757;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
        }

        #challengeTitle {
            font-size: 28px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #challengeSentence {
            font-size: 24px;
            color: white;
            margin-bottom: 20px;
            line-height: 1.6;
            letter-spacing: 2px;
        }

        #challengeSentence .char {
            position: relative;
        }

        #challengeSentence .char.correct {
            color: #10b981;
        }

        #challengeSentence .char.current {
            background: rgba(255, 215, 0, 0.3);
            animation: blink 0.8s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #challengeInput {
            display: none;
        }

        /* Challenge keyboard - hidden on desktop */
        #challengeKeyboard {
            display: none;
        }

        @media (max-width: 768px) {
            #challengeTitle {
                font-size: 20px;
            }

            #challengeTimer {
                font-size: 20px;
            }

            #challengeSentence {
                font-size: 18px;
                letter-spacing: 1px;
            }

            #challengeInput {
                font-size: 14px;
            }

            #challengeContent {
                padding: 20px;
            }

            /* Show keyboard on mobile/tablet */
            #challengeKeyboard {
                display: flex;
                flex-direction: column;
                gap: 0;
                width: 100%;
                position: fixed;
                bottom: 0;
                left: 0;
                z-index: 3000;
            }

            .challenge-keyboard-row {
                display: flex;
                justify-content: center;
                gap: 0;
            }

            .challenge-key {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                font-size: 18px;
                font-weight: bold;
                font-family: 'Press Start 2P', cursive;
                height: 52px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 0;
                cursor: pointer;
                transition: all 0.1s;
                user-select: none;
                -webkit-user-select: none;
                -webkit-tap-highlight-color: transparent;
                border-right: 0.5px solid rgba(255, 255, 255, 0.1);
                border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
            }

            .challenge-key:active {
                background: rgba(16, 185, 129, 0.5);
                transform: scale(0.95);
            }

            .challenge-keyboard-row:first-child .challenge-key {
                width: calc(100% / 10);
            }

            .challenge-keyboard-row:nth-child(2) .challenge-key {
                width: calc(100% / 9);
            }

            .challenge-keyboard-row:nth-child(3) .challenge-key {
                width: calc(100% / 8);  /* 8 keys now (removed space) */
            }

            .challenge-keyboard-row:nth-child(4) .challenge-key {
                width: 100%;  /* Full width spacebar */
            }

            .challenge-key.spacebar {
                width: 100%;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .challenge-key {
                height: 50px;
                font-size: 16px;
            }
        }

        @media (max-width: 375px) {
            .challenge-key {
                height: 48px;
                font-size: 14px;
            }
        }


        /* Time Selection Screen */
        #timeSelection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile */
            background: radial-gradient(ellipse at center, #1a2942 0%, #0a1628 50%, #000814 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 20px;
        }
        
        /* Floating words background */
        #floatingWordsBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }
        
        .floating-word {
            position: absolute;
            background: rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 16px;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.15);
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 2px;
            pointer-events: none;
        }
        
        @keyframes float-across {
            0% {
                transform: translate(0, 0);
                opacity: 0;
            }
            10% {
                opacity: 0.1;
            }
            90% {
                opacity: 0.1;
            }
            100% {
                transform: translate(var(--end-x), var(--end-y));
                opacity: 0;
            }
        }

        #timeSelection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(1px 1px at 15% 55%, white, transparent),
                radial-gradient(2px 2px at 70% 25%, white, transparent),
                radial-gradient(1px 1px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 25% 90%, white, transparent);
            background-size: 200% 200%, 300% 300%, 250% 250%, 280% 280%, 220% 220%, 
                             260% 260%, 290% 290%, 240% 240%, 270% 270%, 230% 230%;
            background-position: 0% 0%, 40% 60%, 50% 50%, 80% 10%, 90% 60%, 
                                 33% 80%, 15% 55%, 70% 25%, 45% 15%, 25% 90%;
            background-repeat: repeat;
            opacity: 0.6;
            z-index: 0;
        }

        #timeSelection.hidden {
            display: none;
        }

        #startScreenContent {
            background: rgba(26, 41, 66, 0.6);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px 24px;  /* Match tablet size */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            max-width: 480px;  /* Keep this for desktop max-width */
            position: relative;
            z-index: 10;
        }

        #startScreenContent #rocketIcon {
            font-size: 36px;  /* Match tablet size */
            text-align: center;
            margin-bottom: 20px;
            animation: rotate360 8s linear infinite;
        }

        @keyframes rotate360 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #gameTitle {
            font-size: 16px;  /* Match tablet size */
            font-weight: bold;
            background: linear-gradient(135deg, #ff8c00 0%, #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            line-height: 1.2;
            margin-bottom: 10px;
        }

        #gameSubtitle {
            font-size: 9px;  /* Match tablet size */
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 40px;
        }

        #difficultyOptions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .difficulty-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 14px;  /* Match tablet size */
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-option:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: rgba(78, 205, 196, 0.6);
            transform: scale(1.05);
        }

        .difficulty-name {
            font-size: 13px;  /* Match tablet size */
            font-weight: bold;
            color: white;
            margin-bottom: 5px;
        }

        .difficulty-desc {
            font-size: 9px;  /* Match tablet size */
            color: rgba(255, 255, 255, 0.6);
        }

        /* Screen shake animation */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }

        .shake {
            animation: shake 0.5s;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                overflow: hidden;
            }
            
            #gun {
                font-size: 50px;
                margin-bottom: 180px;
            }
            
            #inputDisplay {
                font-size: 16px;
                padding: 10px 20px;
                min-width: 150px;
                bottom: 15px;
            }
            
            #inputDisplay.active {
                min-width: 220px;
            }
            
            .invader-emoji {
                font-size: 28px;
            }
            .invader-word {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            #topbar {
                padding: 8px 12px;
            }
            
            #difficultyDisplay {
                font-size: 12px;
                padding: 6px 10px;
                height: 32px;
            }
            
            #categoryDisplay {
                font-size: 12px;
                padding: 6px 10px;
                height: 32px;
            }
            
            #score {
                font-size: 12px;
                padding: 6px 10px;
                height: 32px;
            }
            
            #pauseBtn, #restartGameBtn, #homeBtn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }
            
            #pauseBtn {
                display: none;  /* Hide pause button on mobile */
            }
            
            #pauseBtn .material-symbols-outlined,
            #restartGameBtn .material-symbols-outlined,
            #homeBtn .material-symbols-outlined {
                font-size: 18px;  /* Increased to 18px (was 16px) */
            }
            
            /* Game Over Screen Mobile */
            #gameOver h1 {
                font-size: 48px;
                margin-bottom: 15px;
            }
            
            #finalScore {
                font-size: 24px;
                margin-bottom: 25px;
            }
            
            #restartBtn {
                font-size: 16px;
                padding: 12px 30px;
            }
            
            /* Start Screen Mobile */
            #startScreenContent {
                padding: 20px 24px;  /* Reduced by 20% (was 25px 30px) */
                max-width: 90%;
            }
            
            #rocketIcon {
                font-size: 36px;  /* Reduced by 20% (was 45px) */
            }
            
            #gameTitle {
                font-size: 16px;  /* Reduced by 20% (was 20px in desktop, keeping proportion) */
            }
            
            #gameSubtitle {
                font-size: 9px;  /* Reduced proportionally */
            }
            
            .difficulty-option {
                padding: 12px 14px;  /* Reduced by 20% (was 15px 18px) */
            }
            
            .difficulty-name {
                font-size: 13px;  /* Reduced by ~20% (was 16px) */
            }
            
            .difficulty-desc {
                font-size: 9px;
            }
        }
        
        @media (max-width: 480px) {
            #gun {
                font-size: 40px;
                margin-bottom: 160px;
            }
            
            #inputDisplay {
                font-size: 14px;
                padding: 8px 16px;
                min-width: 120px;
                bottom: 10px;
            }
            
            #inputDisplay.active {
                min-width: 180px;
            }
            
            .invader-emoji {
                font-size: 24px;
            }
            
            .invader-word {
                font-size: 10px;
                padding: 3px 7px;
            }
            
            #topbar {
                padding: 6px 10px;
            }
            
            #difficultyDisplay {
                font-size: 10px;
                padding: 5px 8px;
                height: 28px;
            }
            
            #categoryDisplay {
                font-size: 10px;
                padding: 5px 8px;
                height: 28px;
            }
            
            #score {
                font-size: 10px;
                padding: 5px 8px;
                height: 28px;
            }
            
            #pauseBtn, #restartGameBtn, #homeBtn {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }
            
            #pauseBtn .material-symbols-outlined,
            #restartGameBtn .material-symbols-outlined,
            #homeBtn .material-symbols-outlined {
                font-size: 14px;
            }
            
            #leftControls {
                gap: 10px;
            }
            
            #rightControls {
                gap: 10px;
            }
            
            /* Game Over Screen Small Mobile */
            #gameOver {
                padding: 20px;
            }
            
            #gameOver h1 {
                font-size: 36px;
                margin-bottom: 12px;
            }
            
            #finalScore {
                font-size: 20px;
                margin-bottom: 20px;
            }
            
            #restartBtn {
                font-size: 14px;
                padding: 10px 25px;
            }
            
            /* Start Screen Small Mobile */
            #startScreenContent {
                padding: 16px 20px;  /* Reduced by 20% (was 20px 25px) */
                max-width: 95%;
            }
            
            #startScreenContent #rocketIcon {
                font-size: 32px;  /* Reduced by 20% (was 40px) */
            }
            
            #gameTitle {
                font-size: 16px;  /* Keeping consistent with main mobile breakpoint */
            }
            
            #gameSubtitle {
                font-size: 8px;  /* Reduced by 20% (was 10px) */
            }
            
            #difficultyOptions {
                gap: 10px;  /* Reduced slightly (was 12px) */
            }
            
            .difficulty-option {
                padding: 12px 15px;
            }
            
            .difficulty-name {
                font-size: 14px;
            }
            
            .difficulty-desc {
                font-size: 8px;
            }
        }
        
        /* Extra small screens (iPhone SE, etc) */
        @media (max-width: 375px) {
            #gameOver h1 {
                font-size: 32px;
            }
            
            #finalScore {
                font-size: 18px;
            }
            
            #restartBtn {
                font-size: 12px;
                padding: 8px 20px;
            }
            
            #gameTitle {
                font-size: 14px;  /* Reduced by ~30% from 20px */
            }
            
            .difficulty-name {
                font-size: 11px;  /* Reduced slightly (was 13px) */
            }
        }
    </style>
</head>
<body>
    <div id="topbar">
        <div id="leftControls">
            <div id="score">Score: <span id="scoreValue">0</span></div>
            <div id="difficultyDisplay">Easy</div>
            <div id="categoryDisplay">All</div>
        </div>
        <div id="rightControls">
            <button id="autoTestToggle" style="background: #3b82f6; margin-right: 10px; display: none;" title="Toggle Auto-Test Mode">
                <span style="font-size: 14px;">ðŸ¤– TEST</span>
            </button>
            <button id="celebrationPreviewBtn" style="background: #10b981; margin-right: 10px; display: none;" title="Preview Celebration">
                <span style="font-size: 14px;">ðŸŽ‰</span>
            </button>
            <button id="pauseBtn"><span class="material-symbols-outlined">pause</span></button>
            <button id="restartGameBtn"><span class="material-symbols-outlined">refresh</span></button>
            <button id="homeBtn"><span class="material-symbols-outlined">home</span></button>
        </div>
    </div>

    <div id="gameContainer" tabindex="0">
        <div id="topSide"></div>
        <div id="bottomSide">
            <div id="gun">ðŸš€</div>
            <div id="inputDisplay"></div>
            <input type="text" id="mobileInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            
            <!-- On-screen keyboard -->
            <div id="onScreenKeyboard">
                <div class="keyboard-row">
                    <button class="key" data-key="q">Q</button>
                    <button class="key" data-key="w">W</button>
                    <button class="key" data-key="e">E</button>
                    <button class="key" data-key="r">R</button>
                    <button class="key" data-key="t">T</button>
                    <button class="key" data-key="y">Y</button>
                    <button class="key" data-key="u">U</button>
                    <button class="key" data-key="i">I</button>
                    <button class="key" data-key="o">O</button>
                    <button class="key" data-key="p">P</button>
                </div>
                <div class="keyboard-row">
                    <button class="key" data-key="a">A</button>
                    <button class="key" data-key="s">S</button>
                    <button class="key" data-key="d">D</button>
                    <button class="key" data-key="f">F</button>
                    <button class="key" data-key="g">G</button>
                    <button class="key" data-key="h">H</button>
                    <button class="key" data-key="j">J</button>
                    <button class="key" data-key="k">K</button>
                    <button class="key" data-key="l">L</button>
                </div>
                <div class="keyboard-row">
                    <button class="key" data-key="z">Z</button>
                    <button class="key" data-key="x">X</button>
                    <button class="key" data-key="c">C</button>
                    <button class="key" data-key="v">V</button>
                    <button class="key" data-key="b">B</button>
                    <button class="key" data-key="n">N</button>
                    <button class="key" data-key="m">M</button>
                </div>
            </div>
        </div>
        
        <!-- Number keyboard for math mode -->
        <div id="numberKeyboard">
            <div class="keyboard-row">
                <button class="key" data-key="1">1</button>
                <button class="key" data-key="2">2</button>
                <button class="key" data-key="3">3</button>
                <button class="key" data-key="4">4</button>
                <button class="key" data-key="5">5</button>
            </div>
            <div class="keyboard-row">
                <button class="key" data-key="6">6</button>
                <button class="key" data-key="7">7</button>
                <button class="key" data-key="8">8</button>
                <button class="key" data-key="9">9</button>
                <button class="key" data-key="0">0</button>
            </div>
        </div>
    </div>

    <!-- Time Selection Screen (outside gameContainer) -->
    <div id="timeSelection">
        <!-- Floating words background -->
        <div id="floatingWordsBackground"></div>
        
        <div id="startScreenContent">
            <div id="rocketIcon">ðŸš€</div>
            <h1 id="gameTitle">Word Shooter!</h1>
            <p id="gameSubtitle">Show your typing skills</p>
            
            <div id="difficultyOptions">
                <div class="difficulty-option" data-difficulty="easy">
                    <div class="difficulty-name">Easy</div>
                    <div class="difficulty-desc">Slow invaders, more time</div>
                </div>
                
                <div class="difficulty-option" data-difficulty="medium">
                    <div class="difficulty-name">Medium</div>
                    <div class="difficulty-desc">Balanced challenge</div>
                </div>
                
                <div class="difficulty-option" data-difficulty="hard">
                    <div class="difficulty-name">Hard</div>
                    <div class="difficulty-desc">Fast invaders, quick typing</div>
                </div>
                
                <div class="difficulty-option" data-difficulty="superhard">
                    <div class="difficulty-name">Superb</div>
                    <div class="difficulty-desc">Expert typers only!</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Game Over Screen (outside gameContainer) -->
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <div id="finalScore"></div>
        <button id="restartBtn">Restart Game</button>
    </div>

    <!-- Celebration Screen (Score 1000) -->
    <div id="celebrationScreen" style="display: none;">
        <div id="celebrationTopBar">
            <div class="celebration-title">Word Shooter!</div>
            <div class="celebration-buttons">
                <button id="celebrationTopHomeBtn" class="celebration-top-btn" title="Home">
                    <span class="material-symbols-outlined">home</span>
                </button>
                <button id="celebrationTopShareBtn" class="celebration-top-btn" title="Share">
                    <span class="material-symbols-outlined">share</span>
                </button>
            </div>
        </div>
        <div class="hover-3d-wrapper">
            <div class="hover-3d" id="celebrationCardWrapper">
                <div id="celebrationCard">
                    <div id="celebrationHeader">
                        <div class="header-left">
                            <div class="header-label">Score</div>
                            <div class="header-rank" id="playerRank">PRO</div>
                        </div>
                        <div class="header-value" id="celebrationScoreValue">0</div>
                    </div>
                    
                    <div id="celebrationBody">
                        <div class="left-stats">
                            <div class="stat-item">
                                <div class="stat-label">WPM</div>
                                <div class="stat-value" id="celebrationWpm">0</div>
                            </div>
                            
                            <div class="stat-item">
                                <div class="stat-label">ACCURACY</div>
                                <div class="stat-value" id="celebrationAccuracy">0%</div>
                            </div>
                        </div>
                        
                        <div id="rocketIcon">ðŸš€</div>
                        
                        <div class="bottom-stats">
                            <div class="bottom-stats-left">
                                <div class="bottom-stat-label">Incorrect attempts</div>
                                <div class="bottom-stat-label">Missed attempts</div>
                            </div>
                            <div class="bottom-stats-right">
                                <div class="bottom-stat-value" id="celebrationIncorrect">0</div>
                                <div class="bottom-stat-value" id="celebrationMissed">0</div>
                            </div>
                        </div>
                        
                        <div class="graph-container">
                            <canvas id="performanceGraph" width="520" height="300"></canvas>
                            <div class="graph-labels">
                                <div class="graph-time-label start" id="graphStartTime">0:00</div>
                                <div class="graph-time-label center" id="graphCenterTime">(15 min)</div>
                                <div class="graph-time-label end" id="graphEndTime">0:15</div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 8 empty divs needed for the 3D effect -->
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
        </div>
    </div>

    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseContent">
            <div id="pauseMicrocopy"></div>
            <div id="pauseIcon">
                <span class="material-symbols-outlined">play_arrow</span>
                <span class="pause-text">Continue</span>
            </div>
        </div>
    </div>

    <!-- Challenge Screen -->
    <div id="challengeScreen">
        <div id="challengeContent">
            <div id="challengeTimer">20 Sec</div>
            <h2 id="challengeTitle">SPEED ROUND</h2>
            <div id="challengeSentence"></div>
            <div id="challengeInput"></div>
        </div>
        
        <!-- On-screen keyboard for mobile/tablet -->
        <div id="challengeKeyboard">
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="q">Q</div>
                <div class="challenge-key" data-key="w">W</div>
                <div class="challenge-key" data-key="e">E</div>
                <div class="challenge-key" data-key="r">R</div>
                <div class="challenge-key" data-key="t">T</div>
                <div class="challenge-key" data-key="y">Y</div>
                <div class="challenge-key" data-key="u">U</div>
                <div class="challenge-key" data-key="i">I</div>
                <div class="challenge-key" data-key="o">O</div>
                <div class="challenge-key" data-key="p">P</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="a">A</div>
                <div class="challenge-key" data-key="s">S</div>
                <div class="challenge-key" data-key="d">D</div>
                <div class="challenge-key" data-key="f">F</div>
                <div class="challenge-key" data-key="g">G</div>
                <div class="challenge-key" data-key="h">H</div>
                <div class="challenge-key" data-key="j">J</div>
                <div class="challenge-key" data-key="k">K</div>
                <div class="challenge-key" data-key="l">L</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key" data-key="z">Z</div>
                <div class="challenge-key" data-key="x">X</div>
                <div class="challenge-key" data-key="c">C</div>
                <div class="challenge-key" data-key="v">V</div>
                <div class="challenge-key" data-key="b">B</div>
                <div class="challenge-key" data-key="n">N</div>
                <div class="challenge-key" data-key="m">M</div>
                <div class="challenge-key" data-key="backspace">âŒ«</div>
            </div>
            <div class="challenge-keyboard-row">
                <div class="challenge-key spacebar" data-key=" ">Space</div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        const game = {
            score: 0,
            highestScore: 0,
            currentInput: '',
            invaders: [],
            bullets: [],
            targetInvader: null,
            isGameOver: false,
            isPaused: false,
            difficulty: 'easy',
            lastSpawn: 0,
            spawnInterval: 2500,
            invaderSpeed: 0.3,
            maxInvaders: 3,
            isChallenge: false,
            challengeTimer: null,
            challengeTimeLeft: 20,
            completedChallenges: [],
            isMathMode: false,
            currentMathQuestion: null,
            isLetterMode: false,
            celebrationShown: false,
            // Stats tracking for celebration
            startTime: null,
            totalCharactersTyped: 0,
            correctCharacters: 0,
            incorrectAttempts: 0,
            missedWords: 0,
            fastestWordTime: null,
            wordStartTime: null,
            // Performance history for graph (track WPM and accuracy over time)
            wpmHistory: [],
            accuracyHistory: [],
            lastPerformanceCheck: null
        };

        // Challenge sentences for milestone scores
        const challengeSentences = [
            "Jovial zebras quickly vexed my big friend Chuck.",
            "Pack my box with five dozen liquor jugs.",
            "The quick brown fox jumps over the lazy dog.",
            "Crazy Fredrick bought many very exquisite opal jewels.",
            "A wizard's job is to vex chumps quickly in fog.",
            "Sympathizing would fix Quaker objectives justly."
        ];
        
        const challengeMilestones = [200, 300, 400, 500, 600, 700];

        // Letters for letter mode
        const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');

        // Math mode functions
        function generateMathQuestion() {
            const operations = ['+', '-', '*'];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            
            let num1, num2, answer, displayOperation;
            
            switch(operation) {
                case '+':
                    num1 = Math.floor(Math.random() * 50) + 1;
                    num2 = Math.floor(Math.random() * 50) + 1;
                    answer = num1 + num2;
                    displayOperation = '+';
                    break;
                case '-':
                    num1 = Math.floor(Math.random() * 50) + 20;
                    num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
                    answer = num1 - num2;
                    displayOperation = '-';
                    break;
                case '*':
                    num1 = Math.floor(Math.random() * 12) + 1;
                    num2 = Math.floor(Math.random() * 12) + 1;
                    answer = num1 * num2;
                    displayOperation = 'x';  // Use 'x' instead of '*' for display
                    break;
            }
            
            return {
                question: `${num1}${displayOperation}${num2}`,
                answer: answer.toString()
            };
        }

        // Word list for invaders - diverse vocabulary to avoid repetition
        // Categorized word lists - ALL REAL WORDS
        const wordCategories = {
            all: [
                // Common animals
                'dog', 'cat', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'deer',
                'rabbit', 'mouse', 'rat', 'snake', 'frog', 'fish', 'bird', 'eagle',
                'hawk', 'owl', 'crow', 'duck', 'goose', 'swan', 'horse', 'cow',
                'pig', 'sheep', 'goat', 'chicken', 'turkey', 'elephant', 'rhino', 'hippo',
                
                // Common plants
                'rose', 'tulip', 'daisy', 'lily', 'orchid', 'violet', 'jasmine', 'sunflower',
                'oak', 'pine', 'maple', 'birch', 'willow', 'palm', 'bamboo', 'cactus',
                'fern', 'moss', 'ivy', 'grass', 'wheat', 'rice', 'corn', 'tomato',
                'potato', 'carrot', 'lettuce', 'spinach', 'basil', 'mint', 'sage', 'thyme',
                
                // Common science words
                'atom', 'cell', 'gene', 'solar', 'lunar', 'planet', 'orbit', 'energy',
                'force', 'gravity', 'matter', 'quantum', 'carbon', 'oxygen', 'nitrogen', 'hydrogen',
                'electron', 'proton', 'neutron', 'molecule', 'protein', 'enzyme', 'virus', 'bacteria',
                'plasma', 'crystal', 'magma', 'lava', 'fossil', 'mineral', 'climate', 'ocean',
                
                // Common Gen Z words
                'slay', 'vibe', 'fire', 'lit', 'cap', 'bet', 'flex', 'goat',
                'yeet', 'mood', 'fam', 'bruh', 'bussin', 'drip', 'sus', 'valid',
                'cringe', 'toxic', 'savage', 'extra', 'basic', 'salty', 'vibes', 'energy',
                'squad', 'goals', 'icon', 'legend', 'queen', 'king', 'epic', 'dope',
                
                // General words
                'house', 'tree', 'water', 'fire', 'earth', 'wind', 'stone', 'metal',
                'wood', 'glass', 'paper', 'book', 'pen', 'desk', 'chair', 'table',
                'door', 'window', 'wall', 'floor', 'roof', 'garden', 'park', 'road',
                'bridge', 'river', 'lake', 'ocean', 'mountain', 'valley', 'forest', 'field',
                'cloud', 'rain', 'snow', 'sun', 'moon', 'star', 'night', 'day',
                'morning', 'evening', 'spring', 'summer', 'autumn', 'winter', 'season', 'year'
            ],
            
            animals: [
                'dog', 'cat', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'deer',
                'rabbit', 'mouse', 'rat', 'hamster', 'guinea', 'squirrel', 'beaver', 'otter',
                'snake', 'lizard', 'turtle', 'frog', 'toad', 'newt', 'salamander', 'gecko',
                'fish', 'shark', 'whale', 'dolphin', 'seal', 'walrus', 'octopus', 'squid',
                'bird', 'eagle', 'hawk', 'falcon', 'owl', 'crow', 'raven', 'parrot',
                'duck', 'goose', 'swan', 'penguin', 'ostrich', 'emu', 'peacock', 'heron',
                'horse', 'donkey', 'zebra', 'cow', 'bull', 'buffalo', 'bison', 'ox',
                'pig', 'boar', 'sheep', 'ram', 'goat', 'llama', 'alpaca', 'camel',
                'chicken', 'rooster', 'turkey', 'pheasant', 'quail', 'pigeon', 'dove', 'sparrow',
                'elephant', 'rhino', 'hippo', 'giraffe', 'zebra', 'antelope', 'gazelle', 'impala',
                'monkey', 'ape', 'gorilla', 'chimp', 'lemur', 'baboon', 'gibbon', 'orangutan',
                'kangaroo', 'koala', 'wombat', 'wallaby', 'platypus', 'echidna', 'possum', 'bandicoot',
                'bee', 'wasp', 'ant', 'beetle', 'butterfly', 'moth', 'fly', 'mosquito',
                'spider', 'scorpion', 'mantis', 'cricket', 'grasshopper', 'dragonfly', 'ladybug', 'firefly'
            ],
            
            plants: [
                'rose', 'tulip', 'daisy', 'lily', 'orchid', 'violet', 'jasmine', 'sunflower',
                'poppy', 'peony', 'iris', 'carnation', 'marigold', 'zinnia', 'petunia', 'begonia',
                'oak', 'pine', 'maple', 'birch', 'willow', 'elm', 'ash', 'beech',
                'palm', 'cedar', 'spruce', 'fir', 'cypress', 'redwood', 'sequoia', 'mahogany',
                'bamboo', 'cactus', 'succulent', 'aloe', 'agave', 'yucca', 'jade', 'ficus',
                'fern', 'moss', 'lichen', 'algae', 'seaweed', 'kelp', 'ivy', 'vine',
                'grass', 'wheat', 'rice', 'corn', 'barley', 'oats', 'rye', 'millet',
                'tomato', 'potato', 'carrot', 'onion', 'garlic', 'pepper', 'cucumber', 'lettuce',
                'spinach', 'cabbage', 'broccoli', 'cauliflower', 'celery', 'radish', 'turnip', 'beet',
                'basil', 'mint', 'sage', 'thyme', 'oregano', 'parsley', 'cilantro', 'dill',
                'lavender', 'rosemary', 'chamomile', 'hibiscus', 'lotus', 'azalea', 'camellia', 'magnolia',
                'apple', 'orange', 'banana', 'grape', 'cherry', 'peach', 'pear', 'plum',
                'mango', 'papaya', 'coconut', 'pineapple', 'melon', 'berry', 'lemon', 'lime'
            ],
            
            science: [
                // Physics & Chemistry
                'atom', 'molecule', 'electron', 'proton', 'neutron', 'photon', 'quark', 'ion',
                'plasma', 'nucleus', 'isotope', 'catalyst', 'enzyme', 'polymer', 'crystal', 'alloy',
                'quantum', 'particle', 'matter', 'energy', 'entropy', 'velocity', 'momentum', 'friction',
                'gravity', 'radiation', 'magnetic', 'electric', 'thermal', 'kinetic', 'potential', 'force',
                
                // Biology & Medicine
                'cell', 'tissue', 'organ', 'genome', 'gene', 'protein', 'amino', 'lipid',
                'membrane', 'mitosis', 'meiosis', 'nucleus', 'ribosome', 'organelle', 'cytoplasm', 'chloroplast',
                'bacteria', 'virus', 'pathogen', 'antibody', 'antigen', 'immune', 'vaccine', 'syndrome',
                'neuron', 'synapse', 'hormone', 'insulin', 'cortisol', 'dopamine', 'serotonin', 'adrenaline',
                
                // Earth & Space Sciences
                'asteroid', 'comet', 'nebula', 'galaxy', 'planet', 'orbit', 'eclipse', 'cosmos',
                'meteor', 'crater', 'lunar', 'solar', 'stellar', 'cosmic', 'quasar', 'pulsar',
                'geology', 'mineral', 'crystal', 'fossil', 'sediment', 'magma', 'lava', 'tectonic',
                'seismic', 'volcano', 'erosion', 'glacier', 'ocean', 'climate', 'ozone', 'carbon',
                
                // Advanced Scientific Terms
                'algorithm', 'quantum', 'spectrum', 'frequency', 'wavelength', 'amplitude', 'resonance', 'diffraction',
                'osmosis', 'diffusion', 'synthesis', 'analysis', 'hypothesis', 'theory', 'axiom', 'theorem',
                'vector', 'matrix', 'exponential', 'logarithm', 'calculus', 'topology', 'entropy', 'equilibrium'
            ],
            
            genz: [
                // Gen Z slang and expressions
                'slay', 'vibe', 'fire', 'lit', 'cap', 'bet', 'flex', 'goat',
                'yeet', 'stan', 'simp', 'mood', 'fam', 'bruh', 'lowkey', 'highkey',
                'bussin', 'sheesh', 'drip', 'sus', 'valid', 'rent', 'snatched', 'slaps',
                'hits', 'ghosts', 'cringe', 'toxic', 'savage', 'extra', 'basic', 'salty',
                'shook', 'woke', 'clout', 'hype', 'ghost', 'finsta', 'main', 'spam',
                'tea', 'shade', 'glow', 'snack', 'ship', 'squad', 'goals', 'vibes',
                'energy', 'aura', 'serves', 'period', 'icon', 'legend', 'queen', 'king',
                'bop', 'slap', 'banger', 'tracks', 'tunes', 'jams', 'beats', 'bars',
                'fire', 'flames', 'heat', 'hot', 'cold', 'fresh', 'clean', 'smooth',
                'crisp', 'sharp', 'tight', 'solid', 'dope', 'sick', 'ill', 'wicked',
                'crazy', 'insane', 'mental', 'wild', 'epic', 'mega', 'ultra', 'super',
                'hyper', 'turbo', 'nitro', 'blast', 'boom', 'pow', 'bang', 'blast'
            ]
        };
        
        // Current game state
        let currentCategory = 'all';
        let words = wordCategories.all;


        // DOM elements
        const gunElement = document.getElementById('gun');
        const inputDisplay = document.getElementById('inputDisplay');
        const mobileInput = document.getElementById('mobileInput');
        const topSide = document.getElementById('topSide');
        const scoreElement = document.getElementById('score');
        const scoreValue = document.getElementById('scoreValue');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const categoryDisplay = document.getElementById('categoryDisplay');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartGameBtn = document.getElementById('restartGameBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const gameContainer = document.getElementById('gameContainer');
        const timeSelection = document.getElementById('timeSelection');
        const topbar = document.getElementById('topbar');

        // Invader class
        class Invader {
            constructor() {
                // Letter mode - single random letter
                if (game.isLetterMode) {
                    this.word = letters[Math.floor(Math.random() * letters.length)];
                    this.emoji = 'â­';
                    this.isLetter = true;
                    this.isUfo = false;
                    
                    // Estimate width for single letter (approx 100px)
                    const estimatedWidth = 100;
                    this.x = Math.random() * (window.innerWidth - estimatedWidth);
                    this.y = 0;
                    // Slow speed like easy mode
                    this.speedY = 0.3 * (0.8 + Math.random() * 0.4);
                    this.speedX = (Math.random() - 0.5) * 0.3;
                    this.element = this.createElement();
                    this.isDying = false;
                    return;
                }
                
                // 1 in 5 chance to be a UFO
                this.isUfo = Math.random() < 0.2;
                
                // Get words already on screen
                const usedWords = game.invaders
                    .filter(z => !z.isDying)
                    .map(z => z.word);
                
                if (this.isUfo) {
                    // UFO gets longer words (combine two words)
                    let word1, word2;
                    do {
                        word1 = words[Math.floor(Math.random() * words.length)];
                        word2 = words[Math.floor(Math.random() * words.length)];
                        this.word = word1 + word2;
                    } while (usedWords.includes(this.word));
                    this.emoji = 'ðŸ›¸';
                } else {
                    // Pick a word not already on screen
                    let availableWords = words.filter(w => !usedWords.includes(w));
                    // If all words are used, just pick any word
                    if (availableWords.length === 0) {
                        availableWords = words;
                    }
                    this.word = availableWords[Math.floor(Math.random() * availableWords.length)];
                    this.emoji = 'ðŸ‘¾';
                }
                
                // Estimate word label width (rough: 15px per character + 40px padding)
                const estimatedWidth = (this.word.length * 15) + 40;
                this.x = Math.random() * Math.max(100, window.innerWidth - estimatedWidth);
                this.y = 0;
                this.speedY = game.invaderSpeed * (0.8 + Math.random() * 0.4);
                this.speedX = (Math.random() - 0.5) * 0.3;
                this.element = this.createElement();
                this.isDying = false;
            }

            createElement() {
                const invader = document.createElement('div');
                invader.className = 'invader';
                
                // Wrap each character in a span for progress effect
                const wordSpans = this.word.split('').map(char => `<span class="char">${char}</span>`).join('');
                
                // Add rotation class for letter invaders
                const emojiClass = this.isLetter ? 'invader-emoji letter-emoji' : 'invader-emoji';
                
                invader.innerHTML = `
                    <div class="invader-word">${wordSpans}</div>
                    <div class="${emojiClass}">${this.emoji}</div>
                `;
                invader.style.left = this.x + 'px';
                invader.style.top = this.y + 'px';
                gameContainer.appendChild(invader);
                this.wordElement = invader.querySelector('.invader-word');
                return invader;
            }

            createMathElement() {
                const invader = document.createElement('div');
                invader.className = 'invader';
                
                // Display the math question (e.g., "5 + 3")
                const displayText = this.displayWord || this.word;
                const wordSpans = displayText.split('').map(char => `<span class="char">${char}</span>`).join('');
                
                invader.innerHTML = `
                    <div class="invader-word">${wordSpans}</div>
                    <div class="invader-emoji">ðŸ‘½</div>
                `;
                invader.style.left = this.x + 'px';
                invader.style.top = this.y + 'px';
                gameContainer.appendChild(invader);
                this.wordElement = invader.querySelector('.invader-word');
                return invader;
            }

            update() {
                if (this.isDying) return;

                this.y += this.speedY;
                this.x += this.speedX;

                // Get actual element width (word label can be wider than emoji)
                const elementWidth = this.element.offsetWidth || 100;
                
                // Bounce off left and right edges with proper boundary checking
                if (this.x < 0) {
                    this.x = 0;
                    this.speedX *= -1;
                } else if (this.x + elementWidth > window.innerWidth) {
                    this.x = window.innerWidth - elementWidth;
                    this.speedX *= -1;
                }

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                // Start fading when approaching the rocket area (70% down)
                const fadeStart = window.innerHeight * 0.65;
                const fadeEnd = window.innerHeight * 0.70;
                
                if (this.y >= fadeStart && this.y < fadeEnd) {
                    // Fade out as invader approaches the boundary
                    const fadeProgress = (this.y - fadeStart) / (fadeEnd - fadeStart);
                    const opacity = Math.max(0, 1 - fadeProgress);
                    this.element.style.opacity = opacity;
                }

                // Check if reached the rocket area (70% down the screen)
                if (this.y >= fadeEnd) {
                    this.reachedBottomSide();
                }
            }

            reachedBottomSide() {
                if (!this.isDying) {
                    // In math mode, deduct 4 points and spawn new question
                    if (game.isMathMode && this.isMathQuestion) {
                        const penalty = 4;
                        const oldScore = game.score;
                        game.score = Math.max(0, game.score - penalty);
                        
                        // Animate score decrease
                        scoreValue.classList.remove('score-increase', 'score-decrease');
                        void scoreValue.offsetWidth; // Force reflow
                        scoreValue.classList.add('score-decrease');
                        
                        // Animate the counter from old value to new value (counting down)
                        animateValue(scoreValue, oldScore, game.score, 400);
                        
                        // Remove red color after animation
                        setTimeout(() => {
                            scoreValue.classList.remove('score-decrease');
                        }, 500);
                        
                        // Check if game over
                        if (game.score === 0) {
                            gameOver();
                            return;
                        }
                        
                        this.die();
                        // Spawn new math question after a short delay
                        setTimeout(() => {
                            spawnMathInvader();
                        }, 500);
                        return;
                    }
                    
                    // Normal mode - deduct score based on word length (1 point per character)
                    const penalty = this.word.length;
                    const oldScore = game.score;
                    game.score = Math.max(0, game.score - penalty);
                    
                    // Animate score decrease
                    scoreValue.classList.remove('score-increase', 'score-decrease');
                    void scoreValue.offsetWidth; // Force reflow
                    scoreValue.classList.add('score-decrease');
                    
                    // Animate the counter from old value to new value (counting down)
                    animateValue(scoreValue, oldScore, game.score, 400);
                    
                    // Remove red color after animation
                    setTimeout(() => {
                        scoreValue.classList.remove('score-decrease');
                    }, 500);
                    
                    // Check if game over
                    if (game.score === 0) {
                        gameOver();
                    }
                    
                    this.die();
                }
            }

            die() {
                this.isDying = true;
                this.element.classList.add('dying');
                setTimeout(() => {
                    this.element.remove();
                }, 500);
            }

            getCenter() {
                return {
                    x: this.x + 25,
                    y: this.y + 40
                };
            }
        }

        // Bullet class
        class Bullet {
            constructor(targetX, targetY) {
                // Get rocket position and calculate tip based on current rotation
                const gunRect = gunElement.getBoundingClientRect();
                const gunCenterX = gunRect.left + gunRect.width / 2;
                const gunCenterY = gunRect.top + gunRect.height / 2;
                
                // Get current rotation from transform
                const transform = window.getComputedStyle(gunElement).transform;
                let angle = -45; // default angle
                if (transform && transform !== 'none') {
                    const values = transform.split('(')[1].split(')')[0].split(',');
                    const a = parseFloat(values[0]);
                    const b = parseFloat(values[1]);
                    angle = Math.atan2(b, a) * (180 / Math.PI);
                }
                
                // Calculate tip offset - rocket emoji tip is roughly at the top-left when unrotated
                // We need to find where the tip is after rotation
                const tipDistance = 50; // distance from center to visual tip (increased from 40)
                const tipAngle = angle - 45; // The tip is 45 degrees counter-clockwise from the rocket's rotation
                const angleRad = tipAngle * Math.PI / 180;
                
                this.x = gunCenterX + tipDistance * Math.cos(angleRad);
                this.y = gunCenterY + tipDistance * Math.sin(angleRad);
                this.targetX = targetX;
                this.targetY = targetY;
                
                const distance = Math.sqrt(
                    Math.pow(targetX - this.x, 2) + 
                    Math.pow(targetY - this.y, 2)
                );
                
                const speed = 49.5; // Increased by 50% (was 33)
                this.speedX = (targetX - this.x) / distance * speed;
                this.speedY = (targetY - this.y) / distance * speed;
                
                this.element = this.createElement();
                this.distanceTraveled = 0;
                this.maxDistance = distance;
            }

            createElement() {
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                
                // Calculate angle for rotation
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const degrees = angle * (180 / Math.PI);
                
                // Fixed short beam length (like a bullet)
                const beamLength = 40; // Short laser bullet (was distance-based)
                
                // Offset by half the beam width (1.5px) to center it on the tip
                bullet.style.left = (this.x - 1.5) + 'px';
                bullet.style.top = this.y + 'px';
                bullet.style.height = beamLength + 'px';
                bullet.style.transform = `rotate(${degrees + 90}deg)`; // +90 because beam extends downward by default
                bullet.style.transformOrigin = 'top center';
                
                gameContainer.appendChild(bullet);
                return bullet;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.distanceTraveled += Math.sqrt(
                    this.speedX * this.speedX + 
                    this.speedY * this.speedY
                );

                // Calculate angle
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                const degrees = angle * (180 / Math.PI);
                
                // Fixed short beam length (like a bullet) - stays constant
                const beamLength = 40;
                
                // Update position with center offset
                this.element.style.left = (this.x - 1.5) + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.height = beamLength + 'px';
                this.element.style.transform = `rotate(${degrees + 90}deg)`;

                return this.distanceTraveled < this.maxDistance + 50;
            }

            remove() {
                this.element.remove();
            }
        }

        // Spawn invader
        function spawnInvader() {
            // In math mode, only spawn if no active invaders
            if (game.isMathMode) {
                const activeInvaders = game.invaders.filter(z => !z.isDying).length;
                if (activeInvaders === 0) {
                    spawnMathInvader();
                }
                return;
            }
            
            // Letter mode - higher frequency, more invaders allowed
            if (game.isLetterMode) {
                const activeInvaders = game.invaders.filter(z => !z.isDying).length;
                const maxLetterInvaders = 10; // Much higher than normal
                if (activeInvaders < maxLetterInvaders) {
                    const invader = new Invader();
                    game.invaders.push(invader);
                }
                return;
            }
            
            // Normal mode - spawn if under the max invader limit
            const activeInvaders = game.invaders.filter(z => !z.isDying).length;
            if (activeInvaders < game.maxInvaders) {
                const invader = new Invader();
                game.invaders.push(invader);
            }
        }

        function spawnMathInvader() {
            const mathQuestion = generateMathQuestion();
            game.currentMathQuestion = mathQuestion;
            
            // Create a special invader with the math question
            const invader = new Invader();
            invader.word = mathQuestion.answer; // The answer is what we match
            invader.displayWord = mathQuestion.question; // But we display the question
            invader.isMathQuestion = true;
            
            // Position in center horizontally (estimate label width for centering)
            const estimatedWidth = (mathQuestion.question.length * 15) + 40;
            invader.x = Math.max(0, (window.innerWidth / 2) - (estimatedWidth / 2));
            
            // Update the invader element to show the question
            const existingElement = document.querySelector('.invader');
            if (existingElement) {
                existingElement.remove();
            }
            
            invader.element = invader.createMathElement();
            game.invaders.push(invader);
        }

        // Shoot gun
        function shoot(invader) {
            gunElement.classList.add('shoot');
            setTimeout(() => gunElement.classList.remove('shoot'), 100);

            const center = invader.getCenter();
            const bullet = new Bullet(center.x, center.y);
            game.bullets.push(bullet);

            playShootSound();
            
            // Calculate and return travel time for the laser to reach target
            // Distance / speed, then convert frames to milliseconds (assuming 60fps)
            const travelTimeMs = (bullet.maxDistance / 49.5) * (1000 / 60);
            return travelTimeMs;
        }

        // Update score based on word length
        // Animated counter function
        function animateValue(element, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                const value = Math.floor(progress * (end - start) + start);
                element.textContent = value;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    // Ensure final value is set exactly
                    element.textContent = end;
                }
            };
            window.requestAnimationFrame(step);
        }

        function updateScore(word, invader = null) {
            // Scoring: Math = 4 points, Letters = 1 point, Words = length
            let points;
            if (invader && invader.isMathQuestion) {
                points = 4;
            } else if (invader && invader.isLetter) {
                points = 1;
            } else {
                points = word.length;
            }
            
            const oldScore = game.score;
            game.score += points;
            
            // Update highest score if current score exceeds it
            if (game.score > game.highestScore) {
                game.highestScore = game.score;
            }
            
            // Check if we hit a challenge milestone
            checkChallengeMilestone();
            
            // Animate score increase
            scoreValue.classList.remove('score-increase', 'score-decrease');
            void scoreValue.offsetWidth; // Force reflow
            scoreValue.classList.add('score-increase');
            
            // Animate the counter from old value to new value
            animateValue(scoreValue, oldScore, game.score, 400);
            
            // Remove animation class after animation completes
            setTimeout(() => {
                scoreValue.classList.remove('score-increase');
            }, 500);
        }

        // Check if score reached a challenge milestone
        function checkChallengeMilestone() {
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            
            // Check for celebration at 1000
            if (game.score >= 1000 && !game.celebrationShown) {
                console.log('ðŸŽ‰ Score 1000 reached! Showing celebration...');
                game.celebrationShown = true;
                showCelebration();
                return;
            }
            
            // Check for letter mode at 900 (disable math mode first)
            if (game.score >= 900 && !game.isLetterMode) {
                game.isLetterMode = true;
                game.isMathMode = false;  // Disable math mode
                
                // Switch back to letter keyboard on mobile if it was number keyboard
                if (isMobile) {
                    document.getElementById('numberKeyboard').classList.remove('show');
                    document.getElementById('onScreenKeyboard').style.display = 'flex';
                }
                
                // Clear existing invaders
                game.invaders.forEach(inv => {
                    if (!inv.isDying) {
                        inv.element.remove();
                    }
                });
                game.invaders = [];
                return;
            }
            
            // Check for math mode at 800 (only if not yet in letter mode)
            if (game.score >= 800 && game.score < 900 && !game.isMathMode) {
                game.isMathMode = true;
                
                // Switch keyboards on mobile
                if (isMobile) {
                    document.getElementById('onScreenKeyboard').style.display = 'none';
                    document.getElementById('numberKeyboard').classList.add('show');
                }
                
                // Clear existing word invaders and spawn first math question
                game.invaders.forEach(inv => {
                    if (!inv.isDying) {
                        inv.element.remove();
                    }
                });
                game.invaders = [];
                spawnMathInvader();
                return;
            }
            
            // Check for challenge milestones
            for (let milestone of challengeMilestones) {
                if (game.score >= milestone && !game.completedChallenges.includes(milestone)) {
                    game.completedChallenges.push(milestone);
                    startChallenge();
                    break;
                }
            }
        }

        // Rotate rocket to face target
        function rotateRocketToTarget(targetInvader) {
            if (!targetInvader || targetInvader.isDying) {
                gunElement.style.transform = 'rotate(-45deg)'; // Default -45 degree angle (up-right)
                gunElement.classList.remove('aiming');
                return;
            }

            const center = targetInvader.getCenter();
            const shipX = window.innerWidth / 2;
            const shipY = window.innerHeight * 0.7 + 40; // Adjust to rocket tip

            const deltaX = center.x - shipX;
            
            // Determine if target is on left or right side
            // Rotate 30 degrees left (-75Â°) or right (-15Â°) from base -45Â°
            let angleDeg;
            if (deltaX < -100) {
                // Far left - rotate 30Â° left from -45Â° = -75Â°
                angleDeg = -75;
            } else if (deltaX > 100) {
                // Far right - rotate 30Â° right from -45Â° = -15Â°
                angleDeg = -15;
            } else {
                // Center - interpolate between -75Â° and -15Â°
                // Map deltaX from [-100, 100] to [-75, -15]
                const t = (deltaX + 100) / 200; // normalize to [0, 1]
                angleDeg = -75 + (t * 60); // -75 + (0 to 1) * 60 = -75 to -15
            }

            gunElement.classList.add('aiming');
            gunElement.style.transform = `rotate(${angleDeg}deg)`;
        }

        // Simple shoot sound using Web Audio API
        function playShootSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 200;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Function to update word progress (green background fill as you type)
        function updateWordProgress() {
            game.invaders.forEach(invader => {
                if (invader.isDying || !invader.wordElement) return;
                
                if (game.currentInput && invader.word.startsWith(game.currentInput)) {
                    // Calculate progress percentage
                    const progress = (game.currentInput.length / invader.word.length) * 100;
                    invader.wordElement.style.setProperty('--progress', `${progress}%`);
                } else {
                    // No match, reset progress
                    invader.wordElement.style.setProperty('--progress', '0%');
                }
            });
        }

        // Function to update input display
        function updateInputDisplay() {
            // Always update based on current input
            if (game.currentInput && game.currentInput.length > 0) {
                inputDisplay.classList.add('active');
                
                if (game.targetInvader && game.targetInvader.word && !game.isMathMode) {
                    // Show target word with progress (NOT in math mode to avoid revealing answer)
                    const targetWord = game.targetInvader.word;
                    const typed = game.currentInput;
                    
                    let html = '';
                    for (let i = 0; i < targetWord.length; i++) {
                        if (i < typed.length) {
                            html += `<span class="typed">${targetWord[i]}</span>`;
                        } else {
                            html += `<span class="untyped">${targetWord[i]}</span>`;
                        }
                    }
                    inputDisplay.innerHTML = html;
                } else {
                    // Just show what's being typed (no target yet, or in math mode)
                    inputDisplay.innerHTML = `<span class="typed">${game.currentInput}</span>`;
                }
            } else {
                // Clear display when no input
                inputDisplay.innerHTML = '';
                inputDisplay.classList.remove('active');
            }
        }

        // Error sound effect (using Web Audio API)
        // Error sound effect (low pitched beep)
        function playErrorSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Lower frequency for error sound
            oscillator.frequency.value = 150;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
            
            // Show error state on input display
            inputDisplay.classList.add('error');
            setTimeout(() => {
                inputDisplay.classList.remove('error');
            }, 300);
        }

        // Success sound effect (cheerful ascending melody)
        function playSuccessSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create a more pleasant success sound with multiple notes
            const notes = [
                { freq: 523.25, time: 0, duration: 0.08 },      // C5
                { freq: 659.25, time: 0.06, duration: 0.08 },   // E5
                { freq: 783.99, time: 0.12, duration: 0.12 }    // G5
            ];
            
            notes.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = note.freq;
                oscillator.type = 'sine';
                
                const startTime = audioContext.currentTime + note.time;
                gainNode.gain.setValueAtTime(0.15, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + note.duration);
            });
        }

        // Mobile input handler - converts input events to keyboard events
        mobileInput.addEventListener('input', (e) => {
            if (game.isGameOver || game.isPaused) return;
            
            const newValue = e.target.value;
            const oldValue = game.currentInput;
            
            if (newValue.length > oldValue.length) {
                // Character added
                const newChar = newValue[newValue.length - 1].toLowerCase();
                // Trigger the same logic as keyboard
                const keyEvent = new KeyboardEvent('keydown', { key: newChar });
                document.dispatchEvent(keyEvent);
            } else if (newValue.length < oldValue.length) {
                // Character deleted
                const keyEvent = new KeyboardEvent('keydown', { key: 'Backspace' });
                document.dispatchEvent(keyEvent);
            }
            
            // Keep input field in sync but prevent it from getting too long
            if (mobileInput.value.length > 20) {
                mobileInput.value = mobileInput.value.slice(-10);
            }
        });

        // Keep mobile input focused during game (mobile only)
        mobileInput.addEventListener('blur', () => {
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (!game.isGameOver && !game.isPaused && isMobile) {
                setTimeout(() => mobileInput.focus(), 10);
            }
        });

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (game.isGameOver) return;
            
            // Handle challenge mode separately
            if (game.isChallenge) {
                handleChallengeInput(e);
                return;
            }
            
            // Spacebar to pause/unpause
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                togglePause();
                return;
            }
            
            if (game.isPaused) return;

            if (e.key === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
                mobileInput.value = game.currentInput;
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
            } else if (e.key === 'Enter') {
                game.currentInput = '';
                mobileInput.value = '';
                game.targetInvader = null;
                rotateRocketToTarget(null);
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
            } else if (e.key.length === 1 && /[a-z0-9]/i.test(e.key)) {
                const newInput = game.currentInput + e.key.toLowerCase();
                
                // Track character typed
                game.totalCharactersTyped++;
                
                // Check if any invader word starts with this input
                const hasMatch = game.invaders.some(
                    inv => !inv.isDying && inv.word.startsWith(newInput)
                );
                
                if (!hasMatch) {
                    // Track incorrect attempt
                    game.incorrectAttempts++;
                    
                    // Play error sound and reset input completely
                    playErrorSound();
                    game.currentInput = '';
                    mobileInput.value = '';
                    game.targetInvader = null;
                    rotateRocketToTarget(null);
                    updateWordProgress();
                    updateInputDisplay();
                    
                    updateKeyboardHighlight();
                    // Clear all highlights
                    game.invaders.forEach(z => {
                        if (!z.isDying && z.wordElement) {
                            z.wordElement.classList.remove('typing');
                        }
                    });
                    return;
                }
                
                // Track correct character
                game.correctCharacters++;
                
                // Start word timer if this is first character of new word
                if (game.currentInput === '' || !game.wordStartTime) {
                    game.wordStartTime = Date.now();
                }
                
                game.currentInput = newInput;
                mobileInput.value = newInput;
                
                // Check for complete match
                const matchedInvader = game.invaders.find(
                    z => !z.isDying && z.word === game.currentInput
                );
                
                if (matchedInvader) {
                    // Track fastest word time
                    if (game.wordStartTime) {
                        const wordTime = Date.now() - game.wordStartTime;
                        if (!game.fastestWordTime || wordTime < game.fastestWordTime) {
                            game.fastestWordTime = wordTime;
                        }
                        game.wordStartTime = null;
                    }
                    
                    // Play success sound
                    playSuccessSound();
                    
                    // Turn green only on completion
                    matchedInvader.wordElement.classList.add('typing');
                    matchedInvader.wordElement.style.setProperty('--progress', '110%');
                    
                    // Mark as dying immediately to protect the typing class
                    matchedInvader.isDying = true;
                    
                    // Shoot and get travel time
                    const travelTime = shoot(matchedInvader);
                    
                    // Delay invader death animation until laser hits
                    setTimeout(() => {
                        matchedInvader.element.classList.add('dying');
                        setTimeout(() => {
                            matchedInvader.element.remove();
                        }, 500);
                    }, travelTime);
                    
                    updateScore(matchedInvader.word, matchedInvader);
                    
                    // In math mode, spawn new question after answering correctly
                    if (game.isMathMode && matchedInvader.isMathQuestion) {
                        setTimeout(() => {
                            spawnMathInvader();
                        }, travelTime + 500);
                    }
                    
                    game.currentInput = '';
                    mobileInput.value = '';
                    game.targetInvader = null;
                    rotateRocketToTarget(null);
                    updateWordProgress();
                    updateInputDisplay();
                    
                    updateKeyboardHighlight();
                    // Clear all highlights
                    game.invaders.forEach(z => {
                        if (!z.isDying && z.wordElement) {
                            z.wordElement.classList.remove('typing');
                        }
                    });
                    return;
                }
            }
            
            // Update target tracking (but DON'T turn background green until complete)
            let foundMatch = false;
            let targetInvader = null;
            
            game.invaders.forEach(invader => {
                if (invader.isDying || !invader.wordElement) return;
                
                if (game.currentInput && invader.word.startsWith(game.currentInput)) {
                    // DON'T add typing class - no green background until complete
                    if (!foundMatch) {
                        foundMatch = true;
                        targetInvader = invader;
                    }
                }
                
                // Make sure no backgrounds are green while typing
                // But NEVER remove from dying invaders (they should stay green)
                if (!invader.isDying) {
                    invader.wordElement.classList.remove('typing');
                }
            });
            
            // Update word progress (character-level green)
            updateWordProgress();
            
            // Store target and rotate rocket
            game.targetInvader = targetInvader;
            rotateRocketToTarget(targetInvader);
            updateInputDisplay();
            updateKeyboardHighlight();
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (game.isGameOver) return;

            if (!game.isPaused) {
                const deltaTime = timestamp - lastTime;

                // Spawn invaders - faster in letter mode
                const spawnInterval = game.isLetterMode ? 800 : game.spawnInterval; // Much faster for letters
                if (timestamp - game.lastSpawn > spawnInterval) {
                    spawnInvader();
                    game.lastSpawn = timestamp;
                }

                // Update invaders
                game.invaders = game.invaders.filter(invader => {
                    invader.update();
                    if (invader.y >= window.innerHeight + 100) {
                        // Track missed word
                        if (!invader.isDying) {
                            game.missedWords++;
                        }
                        return false;
                    }
                    return true;
                });

                // Update bullets
                game.bullets = game.bullets.filter(bullet => {
                    const alive = bullet.update();
                    
                    if (!alive) {
                        bullet.remove();
                    }
                    return alive;
                });

                // Continuously update rocket rotation to track target
                if (game.targetInvader && !game.targetInvader.isDying) {
                    rotateRocketToTarget(game.targetInvader);
                }

                // Progressive difficulty - gradually increase speed and spawn rate based on score
                if (game.score > 0 && game.score % 50 === 0) {
                    // Gradually increase speed (cap based on difficulty)
                    const speedCap = {
                        'easy': 0.8,
                        'medium': 1.2,
                        'hard': 1.8,
                        'superhard': 2.5
                    };
                    game.invaderSpeed = Math.min(game.invaderSpeed + 0.05, speedCap[game.difficulty]);
                    
                    // Gradually decrease spawn interval (cap based on difficulty)
                    const intervalCap = {
                        'easy': 1500,
                        'medium': 1000,
                        'hard': 700,
                        'superhard': 400
                    };
                    game.spawnInterval = Math.max(game.spawnInterval - 50, intervalCap[game.difficulty]);
                }
            }
            
            lastTime = timestamp;
            requestAnimationFrame(gameLoop);
        }

        // Challenge system functions
        function startChallenge() {
            game.isChallenge = true;
            game.isPaused = true;
            game.challengeTimeLeft = 20;
            game.currentInput = '';
            
            // Pick random sentence that hasn't been used
            const unusedSentences = challengeSentences.filter((s, i) => 
                !game.completedChallenges.includes(challengeMilestones[challengeSentences.indexOf(s)])
            );
            const randomSentence = challengeSentences[Math.floor(Math.random() * challengeSentences.length)];
            
            // Setup challenge screen
            const challengeScreen = document.getElementById('challengeScreen');
            const challengeSentence = document.getElementById('challengeSentence');
            const challengeTimer = document.getElementById('challengeTimer');
            const challengeInput = document.getElementById('challengeInput');
            
            // Wrap each character in a span
            challengeSentence.innerHTML = randomSentence.split('').map(char => 
                `<span class="char">${char}</span>`
            ).join('');
            
            challengeTimer.textContent = `${game.challengeTimeLeft} Sec`;
            challengeInput.textContent = '';
            challengeScreen.classList.add('show');
            
            // Hide normal game keyboard during challenge
            const normalKeyboard = document.getElementById('onScreenKeyboard');
            normalKeyboard.classList.add('hide-for-challenge');
            
            // Start countdown
            game.challengeTimer = setInterval(() => {
                game.challengeTimeLeft--;
                challengeTimer.textContent = `${game.challengeTimeLeft} Sec`;
                
                if (game.challengeTimeLeft <= 0) {
                    failChallenge();
                }
            }, 1000);
            
            // Update current character highlight
            updateChallengeProgress();
        }

        function updateChallengeProgress() {
            const challengeSentence = document.getElementById('challengeSentence');
            const chars = challengeSentence.querySelectorAll('.char');
            const input = game.currentInput;
            
            chars.forEach((char, index) => {
                char.classList.remove('correct', 'current');
                if (index < input.length) {
                    char.classList.add('correct');
                } else if (index === input.length) {
                    char.classList.add('current');
                }
            });
        }

        function completeChallenge() {
            clearInterval(game.challengeTimer);
            game.isChallenge = false;
            game.isPaused = false;
            game.currentInput = '';
            
            const challengeScreen = document.getElementById('challengeScreen');
            challengeScreen.classList.remove('show');
            
            // Restore correct keyboard based on current mode
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                if (game.isMathMode) {
                    // Math mode - show number keyboard
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    // Word/Letter mode - show letter keyboard
                    normalKeyboard.classList.remove('hide-for-challenge');
                    normalKeyboard.style.display = 'flex';
                    numberKeyboard.classList.remove('show');
                }
            } else {
                // Desktop - just unhide
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                normalKeyboard.classList.remove('hide-for-challenge');
            }
            
            // Bonus points for completing challenge
            game.score += 50;
            scoreValue.textContent = game.score;
            
            // Refocus input
            if (isMobile) {
                mobileInput.focus();
            }
        }

        function failChallenge() {
            clearInterval(game.challengeTimer);
            game.isChallenge = false;
            game.isPaused = false;
            game.currentInput = '';
            
            const challengeScreen = document.getElementById('challengeScreen');
            challengeScreen.classList.remove('show');
            
            // Restore correct keyboard based on current mode
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                if (game.isMathMode) {
                    // Math mode - show number keyboard
                    normalKeyboard.style.display = 'none';
                    numberKeyboard.classList.add('show');
                } else {
                    // Word/Letter mode - show letter keyboard
                    normalKeyboard.classList.remove('hide-for-challenge');
                    normalKeyboard.style.display = 'flex';
                    numberKeyboard.classList.remove('show');
                }
            } else {
                // Desktop - just unhide
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                normalKeyboard.classList.remove('hide-for-challenge');
            }
            
            // Penalty for failing challenge
            const penalty = 50;
            game.score = Math.max(0, game.score - penalty);
            scoreValue.textContent = game.score;
            
            // Check if game over
            if (game.score === 0) {
                gameOver();
            }
            
            // Refocus input
            if (isMobile) {
                mobileInput.focus();
            }
        }

        function handleChallengeInput(e) {
            const challengeInput = document.getElementById('challengeInput');
            const challengeSentenceEl = document.getElementById('challengeSentence');
            const targetSentence = challengeSentenceEl.textContent;
            
            if (e.key === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
            } else if (e.key.length === 1) {
                // Only add character if it matches the next expected character (case-insensitive)
                const nextChar = targetSentence[game.currentInput.length];
                if (e.key.toLowerCase() === nextChar.toLowerCase()) {
                    game.currentInput += nextChar; // Use the actual character from sentence (preserves case)
                }
            }
            
            // Update display
            challengeInput.textContent = game.currentInput;
            updateChallengeProgress();
            
            // Check if completed
            if (game.currentInput === targetSentence) {
                completeChallenge();
            }
        }

        // Challenge keyboard event listeners (mobile/tablet)
        const challengeKeys = document.querySelectorAll('.challenge-key');
        challengeKeys.forEach(key => {
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!game.isChallenge) return;
                
                const keyValue = key.getAttribute('data-key');
                
                if (keyValue === 'backspace') {
                    handleChallengeInput({ key: 'Backspace' });
                } else if (keyValue === ' ') {
                    handleChallengeInput({ key: ' ' });
                } else {
                    handleChallengeInput({ key: keyValue });
                }
                
                // Visual feedback
                key.style.background = 'rgba(16, 185, 129, 0.5)';
                setTimeout(() => {
                    key.style.background = '';
                }, 100);
            });
            
            key.addEventListener('click', (e) => {
                e.preventDefault();
                if (!game.isChallenge) return;
                
                const keyValue = key.getAttribute('data-key');
                
                if (keyValue === 'backspace') {
                    handleChallengeInput({ key: 'Backspace' });
                } else if (keyValue === ' ') {
                    handleChallengeInput({ key: ' ' });
                } else {
                    handleChallengeInput({ key: keyValue });
                }
            });
        });

        // Game over
        function gameOver() {
            game.isGameOver = true;
            finalScoreElement.textContent = `Highest Score: ${game.highestScore}`;
            gameOverScreen.classList.add('show');
        }

        // Restart game
        function restartGame() {
            // Clear invaders and bullets
            game.invaders.forEach(z => z.element.remove());
            game.bullets.forEach(b => b.remove());
            
            // Reset all mode flags
            game.isMathMode = false;
            game.isLetterMode = false;
            game.completedChallenges = [];
            
            // Reset keyboards to default (word keyboard on mobile)
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (isMobile) {
                const normalKeyboard = document.getElementById('onScreenKeyboard');
                const numberKeyboard = document.getElementById('numberKeyboard');
                
                normalKeyboard.style.display = 'flex';
                normalKeyboard.classList.remove('hide-for-challenge');
                numberKeyboard.classList.remove('show');
            }
            
            // Hide game container and show time selection screen
            gameContainer.classList.add('hidden');
            timeSelection.classList.remove('hidden');
            gameOverScreen.classList.remove('show');
            topbar.classList.remove('show');
        }

        // Start game with selected difficulty
        function startGame(difficulty) {
            // Difficulty settings
            const difficultySettings = {
                'easy': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.3,
                    maxInvaders: 3
                },
                'medium': {
                    spawnInterval: 1800,
                    invaderSpeed: 0.5,
                    maxInvaders: 5
                },
                'hard': {
                    spawnInterval: 1200,
                    invaderSpeed: 0.8,
                    maxInvaders: 7
                },
                'superhard': {
                    spawnInterval: 800,
                    invaderSpeed: 1.2,
                    maxInvaders: 10
                }
            };
            
            const settings = difficultySettings[difficulty];
            
            // Reset game state
            game.score = 0;
            game.currentInput = '';
            game.invaders = [];
            game.bullets = [];
            game.targetInvader = null;
            game.isGameOver = false;
            game.isPaused = false;
            game.lastSpawn = 0;
            game.difficulty = difficulty;
            game.spawnInterval = settings.spawnInterval;
            game.invaderSpeed = settings.invaderSpeed;
            game.maxInvaders = settings.maxInvaders;
            
            // Reset celebration and stats tracking
            game.celebrationShown = false;
            game.isMathMode = false;
            game.isLetterMode = false;
            game.completedChallenges = [];
            game.startTime = Date.now();
            game.totalCharactersTyped = 0;
            game.correctCharacters = 0;
            game.incorrectAttempts = 0;
            game.missedWords = 0;
            game.fastestWordTime = null;
            game.wordStartTime = null;
            game.wpmHistory = [];
            game.accuracyHistory = [];
            game.lastPerformanceCheck = Date.now();
            
            // Clear mobile input value
            mobileInput.value = '';
            
            // Reset UI
            scoreValue.textContent = '0';
            scoreValue.classList.remove('score-increase', 'score-decrease');
            const difficultyNames = {
                'easy': 'Easy',
                'medium': 'Medium', 
                'hard': 'Hard',
                'superhard': 'Superb'
            };
            difficultyDisplay.textContent = difficultyNames[difficulty];
            
            // Set pause button icon
            const pauseIcon = pauseBtn.querySelector('.material-symbols-outlined');
            if (pauseIcon) pauseIcon.textContent = 'pause';
            
            rotateRocketToTarget(null);
            
            // Hide time selection and show game container
            timeSelection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            topbar.classList.add('show');
            
            // Focus mobile input only on mobile/tablet devices
            // Desktop will use document keydown listener directly
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (isMobile) {
                // Mobile - use the hidden input to capture keyboard
                requestAnimationFrame(() => {
                    mobileInput.focus();
                });
                setTimeout(() => mobileInput.focus(), 50);
                setTimeout(() => mobileInput.focus(), 100);
            } else {
                // Desktop - ensure mobileInput is blurred so document keydown works
                mobileInput.blur();
                // Focus on game container or document body instead
                gameContainer.focus();
            }
            
            // Restart game loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Pause microcopy messages
        const pauseMicrocopyMessages = [
            'Take a deep breath',
            'Stretch your fingers',
            'Are you ready?',
            'You can do this!',
            'This is easy, right?'
        ];

        // Toggle pause
        // Show celebration screen at score 1000
        function showCelebration() {
            game.isPaused = true;
            game.isGameOver = true; // Stop the game loop
            
            // Hide the game container
            document.getElementById('gameContainer').classList.add('hidden');
            
            // Clear all invaders and bullets
            game.invaders.forEach(inv => {
                if (inv.element) inv.element.remove();
            });
            game.bullets.forEach(bullet => {
                if (bullet.element) bullet.element.remove();
            });
            game.invaders = [];
            game.bullets = [];
            
            // Calculate stats
            const totalTimeSeconds = (Date.now() - game.startTime) / 1000;
            const totalTimeMinutes = totalTimeSeconds / 60;
            
            // WPM calculation (assuming average 5 characters per word)
            const wordsTyped = game.correctCharacters / 5;
            const wpm = Math.round(wordsTyped / totalTimeMinutes);
            
            // Accuracy calculation
            const totalAttempts = game.correctCharacters + game.incorrectAttempts;
            const accuracy = totalAttempts > 0 ? Math.round((game.correctCharacters / totalAttempts) * 100) : 100;
            
            // Determine player rank based on WPM and Accuracy
            let rank = 'NOOB';
            if (wpm >= 40 && accuracy >= 85) {
                rank = 'PRO';
            } else if (wpm >= 25 && accuracy >= 70) {
                rank = 'BASIC';
            }
            
            // Reusable countdown animation function
            const animateValue = (elementId, finalValue, duration = 2000, suffix = '') => {
                const element = document.getElementById(elementId);
                let currentValue = 0;
                const steps = 60;
                const increment = finalValue / steps;
                const stepDuration = duration / steps;
                
                const countInterval = setInterval(() => {
                    currentValue += increment;
                    if (currentValue >= finalValue) {
                        currentValue = finalValue;
                        clearInterval(countInterval);
                    }
                    element.textContent = Math.floor(currentValue) + suffix;
                }, stepDuration);
            };
            
            // Update celebration screen with countdown animations
            document.getElementById('playerRank').textContent = rank;
            
            // Animate all numeric values
            animateValue('celebrationScoreValue', game.score, 2000, '');
            animateValue('celebrationWpm', wpm, 2000, '');
            animateValue('celebrationAccuracy', accuracy, 2000, '%');
            animateValue('celebrationIncorrect', game.incorrectAttempts, 2000, '');
            animateValue('celebrationMissed', game.missedWords, 2000, '');
            
            // Update graph time labels with actual clock times
            const startDate = new Date(game.startTime);
            const endDate = new Date();
            
            // Format times as HH:MM or H:MM
            const formatTime = (date) => {
                const hours = date.getHours();
                const minutes = date.getMinutes();
                return `${hours}:${minutes.toString().padStart(2, '0')}`;
            };
            
            const endMinutes = Math.floor(totalTimeMinutes);
            document.getElementById('graphStartTime').textContent = formatTime(startDate);
            document.getElementById('graphCenterTime').textContent = `(${endMinutes} min)`;
            document.getElementById('graphEndTime').textContent = formatTime(endDate);
            
            // Hide keyboard on mobile/tablet
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            if (isMobile) {
                document.getElementById('onScreenKeyboard').style.display = 'none';
                document.getElementById('numberKeyboard').classList.remove('show');
            }
            
            // Hide default top bar
            document.getElementById('topbar').classList.remove('show');
            
            // Draw performance graph
            // Draw performance graph first
            drawPerformanceGraph();
            
            // Show celebration screen
            document.getElementById('celebrationScreen').style.display = 'flex';
            
            // Initialize 3D Hover Effect for Celebration Card (after showing and drawing)
            setTimeout(() => {
                const celebrationCardWrapper = document.getElementById('celebrationCardWrapper');
                if (celebrationCardWrapper) {
                    celebrationCardWrapper.addEventListener('mousemove', (e) => {
                        const rect = celebrationCardWrapper.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;
                        
                        // Calculate rotation (inverted for natural feel)
                        const rotateX = ((y - centerY) / centerY) * -15; // Max 15 degrees
                        const rotateY = ((x - centerX) / centerX) * 15; // Max 15 degrees
                        
                        celebrationCardWrapper.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                    });
                    
                    celebrationCardWrapper.addEventListener('mouseleave', () => {
                        celebrationCardWrapper.style.transform = 'rotateX(0deg) rotateY(0deg)';
                    });
                }
            }, 100);
        }
        
        function drawPerformanceGraph() {
            const canvas = document.getElementById('performanceGraph');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas (transparent background)
            ctx.clearRect(0, 0, width, height);
            
            // Use actual history or generate sample data
            let wpmData = game.wpmHistory.length > 0 ? game.wpmHistory : [];
            let accuracyData = game.accuracyHistory.length > 0 ? game.accuracyHistory : [];
            
            if (wpmData.length < 2) {
                // Generate sample data for preview
                const result = generateSampleDualData();
                wpmData = result.wpm;
                accuracyData = result.accuracy;
            }
            
            const points = wpmData.length;
            const padding = 0;
            const graphWidth = width - padding * 2;
            const graphHeight = height - 40; // Bottom padding for labels
            
            // Create paths for both lines
            const accuracyPath = [];
            const wpmPath = [];
            
            for (let i = 0; i < points; i++) {
                const x = padding + (i / (points - 1)) * graphWidth;
                
                const accValue = accuracyData[i] / 100;
                const accY = height - (accValue * graphHeight);
                accuracyPath.push({ x, y: accY });
                
                const wpmValue = wpmData[i] / 100;
                const wpmY = height - (wpmValue * graphHeight);
                wpmPath.push({ x, y: wpmY });
            }
            
            // Animation setup - no delay
            const animationDuration = 2000; // 2 seconds
            
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw Accuracy (green) - back layer
                drawAnimatedPath(ctx, accuracyPath, progress, '#10b981', 'rgba(16, 185, 129, 0.7)', 'rgba(16, 185, 129, 0.2)', height);
                
                // Draw WPM (yellow) - front layer
                drawAnimatedPath(ctx, wpmPath, progress, '#FFD400', 'rgba(255, 212, 0, 0.7)', 'rgba(255, 212, 0, 0.2)', height);
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            // Start animation immediately
            animate();
        }
        
        function drawAnimatedPath(ctx, path, progress, strokeColor, fillTop, fillBottom, height) {
            if (path.length < 2) return;
            
            // Calculate total path length
            let totalLength = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i - 1].x;
                const dy = path[i].y - path[i - 1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            const targetLength = totalLength * progress;
            
            // Find points along the path up to targetLength
            let currentLength = 0;
            const visiblePath = [path[0]];
            
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i - 1].x;
                const dy = path[i].y - path[i - 1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                
                if (currentLength + segmentLength <= targetLength) {
                    visiblePath.push(path[i]);
                    currentLength += segmentLength;
                } else {
                    // Partial segment
                    const remaining = targetLength - currentLength;
                    const ratio = remaining / segmentLength;
                    const x = path[i - 1].x + dx * ratio;
                    const y = path[i - 1].y + dy * ratio;
                    visiblePath.push({ x, y });
                    break;
                }
            }
            
            if (visiblePath.length < 2) return;
            
            // Draw filled area
            ctx.beginPath();
            ctx.moveTo(visiblePath[0].x, height);
            visiblePath.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(visiblePath[visiblePath.length - 1].x, height);
            ctx.closePath();
            
            // Fill with gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, fillTop);
            gradient.addColorStop(1, fillBottom);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw stroke line
            ctx.beginPath();
            ctx.moveTo(visiblePath[0].x, visiblePath[0].y);
            for (let i = 1; i < visiblePath.length; i++) {
                ctx.lineTo(visiblePath[i].x, visiblePath[i].y);
            }
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }
        
        function generateSampleDualData() {
            const points = 20;
            const wpm = [];
            const accuracy = [];
            
            // Calculate actual final WPM and accuracy
            const totalTimeMinutes = (Date.now() - game.startTime) / 60000;
            const finalWpm = Math.round((game.correctCharacters / 5) / totalTimeMinutes);
            const totalAttempts = game.correctCharacters + game.incorrectAttempts;
            const finalAccuracy = totalAttempts > 0 ? Math.round((game.correctCharacters / totalAttempts) * 100) : 100;
            
            for (let i = 0; i < points; i++) {
                const progress = i / (points - 1);
                
                // WPM starts lower and increases with variance
                const wpmVariance = (Math.random() - 0.5) * 8;
                const wpmValue = Math.max(10, finalWpm * (0.5 + progress * 0.5) + wpmVariance);
                wpm.push(Math.round(wpmValue));
                
                // Accuracy starts higher and stabilizes
                const accuracyVariance = (Math.random() - 0.5) * 5;
                const accuracyValue = Math.max(60, Math.min(100, finalAccuracy * (0.85 + progress * 0.15) + accuracyVariance));
                accuracy.push(Math.round(accuracyValue));
            }
            
            return { wpm, accuracy };
        }

        function togglePause() {
            game.isPaused = !game.isPaused;
            const icon = pauseBtn.querySelector('.material-symbols-outlined');
            if (icon) {
                icon.textContent = game.isPaused ? 'play_arrow' : 'pause';
            }
            
            // Show/hide pause overlay
            const pauseOverlay = document.getElementById('pauseOverlay');
            const pauseMicrocopy = document.getElementById('pauseMicrocopy');
            
            if (game.isPaused) {
                // Select random microcopy message
                const randomIndex = Math.floor(Math.random() * pauseMicrocopyMessages.length);
                pauseMicrocopy.textContent = pauseMicrocopyMessages[randomIndex];
                pauseOverlay.classList.add('show');
            } else {
                pauseOverlay.classList.remove('show');
            }
        }

        // Apply difficulty settings (used when changing difficulty mid-game)
        function applyDifficultySettings(difficulty) {
            const difficultySettings = {
                'easy': {
                    spawnInterval: 2500,
                    invaderSpeed: 0.3,
                    maxInvaders: 3
                },
                'medium': {
                    spawnInterval: 1800,
                    invaderSpeed: 0.5,
                    maxInvaders: 5
                },
                'hard': {
                    spawnInterval: 1200,
                    invaderSpeed: 0.8,
                    maxInvaders: 7
                },
                'superhard': {
                    spawnInterval: 800,
                    invaderSpeed: 1.2,
                    maxInvaders: 10
                }
            };
            
            const settings = difficultySettings[difficulty];
            game.difficulty = difficulty;
            game.spawnInterval = settings.spawnInterval;
            game.invaderSpeed = settings.invaderSpeed;
            game.maxInvaders = settings.maxInvaders;
        }

        // Event listeners
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        
        // Celebration top bar buttons
        document.getElementById('celebrationTopShareBtn').addEventListener('click', async () => {
            const statsText = `ðŸŽ® Type to Shoot Game Results ðŸŽ®

Score: ${game.score}
WPM: ${document.getElementById('celebrationWpm').textContent}
Accuracy: ${document.getElementById('celebrationAccuracy').textContent}
Rank: ${document.getElementById('playerRank').textContent}

Play now at: ${window.location.href}`;

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'Type to Shoot - My Results',
                        text: statsText
                    });
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.log('Share failed:', err);
                        copyToClipboard(statsText);
                    }
                }
            } else {
                copyToClipboard(statsText);
            }
        });
        
        document.getElementById('celebrationTopHomeBtn').addEventListener('click', () => {
            document.getElementById('celebrationScreen').style.display = 'none';
            gameContainer.classList.add('hidden');
            topbar.classList.remove('show');
            timeSelection.classList.remove('hidden');
            
            // Clear invaders and bullets
            game.invaders.forEach(z => z.element.remove());
            game.bullets.forEach(b => b.remove());
            game.invaders = [];
            game.bullets = [];
        });
        
        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Failed to copy results');
            }
            document.body.removeChild(textArea);
        }
        
        // Restart button during game - restarts immediately with same difficulty
        restartGameBtn.addEventListener('click', () => {
            const currentDifficulty = game.difficulty;
            
            // Clear invaders and bullets
            game.invaders.forEach(z => z.element.remove());
            game.bullets.forEach(b => b.remove());
            
            // Restart with same difficulty
            startGame(currentDifficulty);
        });
        
        // Home button - return to main menu
        const homeBtn = document.getElementById('homeBtn');
        homeBtn.addEventListener('click', () => {
            // Clear invaders and bullets
            game.invaders.forEach(z => z.element.remove());
            game.bullets.forEach(b => b.remove());
            game.invaders = [];
            game.bullets = [];
            
            // Hide game container and show time selection
            gameContainer.classList.add('hidden');
            topbar.classList.remove('show');
            timeSelection.classList.remove('hidden');
            
            // Reset game state
            game.isGameOver = false;
            game.isPaused = false;
        });
        
        // Difficulty display click to cycle through levels
        difficultyDisplay.addEventListener('click', () => {
            const difficultyOrder = ['easy', 'medium', 'hard', 'superhard'];
            const currentIndex = difficultyOrder.indexOf(game.difficulty);
            const nextIndex = (currentIndex + 1) % difficultyOrder.length;
            const nextDifficulty = difficultyOrder[nextIndex];
            
            applyDifficultySettings(nextDifficulty);
            
            const difficultyNames = {
                'easy': 'Easy',
                'medium': 'Medium',
                'hard': 'Hard',
                'superhard': 'Superb'
            };
            difficultyDisplay.textContent = difficultyNames[nextDifficulty];
        });
        
        // Category cycling
        categoryDisplay.addEventListener('click', () => {
            const categoryOrder = ['all', 'animals', 'plants', 'science', 'genz'];
            const currentIndex = categoryOrder.indexOf(currentCategory);
            const nextIndex = (currentIndex + 1) % categoryOrder.length;
            currentCategory = categoryOrder[nextIndex];
            
            // Update word list
            words = wordCategories[currentCategory];
            
            const categoryNames = {
                'all': 'All',
                'animals': 'Animals',
                'plants': 'Plants',
                'science': 'Science',
                'genz': 'Gen Z'
            };
            categoryDisplay.textContent = categoryNames[currentCategory];
        });
        
        // Difficulty option selection on start screen - starts game immediately
        const difficultyOptions = document.querySelectorAll('.difficulty-option');
        difficultyOptions.forEach(option => {
            option.addEventListener('click', () => {
                const difficulty = option.getAttribute('data-difficulty');
                const isMobile = window.matchMedia("(max-width: 768px)").matches;
                // Focus mobile input immediately on user interaction (mobile only)
                if (isMobile) {
                    mobileInput.focus();
                }
                // Small delay to ensure focus has taken effect
                setTimeout(() => {
                    startGame(difficulty);
                }, 50);
            });
        });
        
        // Click anywhere on game to refocus mobile input (for mobile keyboard)
        // Click on game area to pause/unpause
        gameContainer.addEventListener('click', (e) => {
            // Don't trigger pause if clicking on buttons, keyboard, or topbar
            if (e.target.closest('#pauseBtn, #restartGameBtn, #homeBtn, #celebrationPreviewBtn, .key, #onScreenKeyboard, #topbar')) {
                return;
            }
            
            const isMobile = window.matchMedia("(max-width: 768px)").matches;
            
            if (!game.isGameOver) {
                // Toggle pause on click/tap
                togglePause();
            }
            
            // Also refocus mobile input if not paused
            if (!game.isGameOver && !game.isPaused && isMobile) {
                mobileInput.focus();
            }
        });
        
        // Pause overlay click to unpause
        const pauseOverlay = document.getElementById('pauseOverlay');
        pauseOverlay.addEventListener('click', () => {
            if (game.isPaused && !game.isGameOver) {
                togglePause();
            }
        });
        
        // On-screen keyboard handler - MOBILE OPTIMIZED
        const keyboardKeys = document.querySelectorAll('.key');
        
        keyboardKeys.forEach(key => {
            // Visual feedback on touch
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                key.classList.add('pressed');
            }, { passive: false });
            
            // Use touchend for better mobile responsiveness
            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove visual feedback
                setTimeout(() => key.classList.remove('pressed'), 100);
                
                if (game.isGameOver || game.isPaused) {
                    return;
                }
                
                const keyValue = key.getAttribute('data-key');
                
                // Directly handle the key press
                handleKeyPress(keyValue);
            }, { passive: false });
            
            // Also keep click for desktop testing
            key.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Visual feedback
                key.classList.add('pressed');
                setTimeout(() => key.classList.remove('pressed'), 100);
                
                if (game.isGameOver || game.isPaused) return;
                
                const keyValue = key.getAttribute('data-key');
                handleKeyPress(keyValue);
            });
        });
        
        // Function to update keyboard key highlighting
        function updateKeyboardHighlight() {
            const keyboardKeys = document.querySelectorAll('.key');
            
            // Clear all active highlights first
            keyboardKeys.forEach(k => k.classList.remove('active'));
            
            // Highlight keys that were typed correctly
            if (game.currentInput && game.targetInvader && !game.targetInvader.isDying) {
                for (let i = 0; i < game.currentInput.length; i++) {
                    const char = game.currentInput[i];
                    keyboardKeys.forEach(k => {
                        if (k.getAttribute('data-key') === char) {
                            k.classList.add('active');
                        }
                    });
                }
            }
        }

        // Function to handle key presses (for both keyboard and on-screen keyboard)
        function handleKeyPress(keyValue) {
            if (game.isGameOver || game.isPaused) return;
            
            if (keyValue === 'Backspace') {
                game.currentInput = game.currentInput.slice(0, -1);
                mobileInput.value = game.currentInput;
                
                // Update target after backspace
                if (game.currentInput.length > 0) {
                    let foundMatch = false;
                    let targetInvader = null;
                    
                    game.invaders.forEach(invader => {
                        if (invader.isDying || !invader.wordElement) return;
                        
                        if (invader.word.startsWith(game.currentInput)) {
                            if (!foundMatch) {
                                foundMatch = true;
                                targetInvader = invader;
                            }
                        }
                    });
                    
                    game.targetInvader = targetInvader;
                    rotateRocketToTarget(targetInvader);
                } else {
                    game.targetInvader = null;
                    rotateRocketToTarget(null);
                }
                
                updateWordProgress();
                updateInputDisplay();
                updateKeyboardHighlight();
            } else if (keyValue.length === 1) {
                const newInput = game.currentInput + keyValue.toLowerCase();
                
                // Check if any invader word starts with this input
                const hasMatch = game.invaders.some(
                    inv => !inv.isDying && inv.word.startsWith(newInput)
                );
                
                if (!hasMatch) {
                    // Play error sound and reset input completely
                    playErrorSound();
                    game.currentInput = '';
                    mobileInput.value = '';
                    game.targetInvader = null;
                    rotateRocketToTarget(null);
                    updateWordProgress();
                    updateInputDisplay();
                    updateKeyboardHighlight();
                    
                    // Clear all highlights
                    game.invaders.forEach(z => {
                        if (!z.isDying && z.wordElement) {
                            z.wordElement.classList.remove('typing');
                        }
                    });
                    return;
                }
                
                game.currentInput = newInput;
                mobileInput.value = newInput;
                
                // Check for complete match
                const matchedInvader = game.invaders.find(
                    z => !z.isDying && z.word === game.currentInput
                );
                
                if (matchedInvader) {
                    // Play success sound
                    playSuccessSound();
                    
                    // Turn green only on completion
                    matchedInvader.wordElement.classList.add('typing');
                    matchedInvader.wordElement.style.setProperty('--progress', '110%');
                    
                    // Mark as dying immediately to protect the typing class
                    matchedInvader.isDying = true;
                    
                    // Shoot and get travel time
                    const travelTime = shoot(matchedInvader);
                    
                    // Delay invader death animation until laser hits
                    setTimeout(() => {
                        matchedInvader.element.classList.add('dying');
                        setTimeout(() => {
                            matchedInvader.element.remove();
                        }, 500);
                    }, travelTime);
                    
                    updateScore(matchedInvader.word, matchedInvader);
                    
                    // In math mode, spawn new question after answering correctly
                    if (game.isMathMode && matchedInvader.isMathQuestion) {
                        setTimeout(() => {
                            spawnMathInvader();
                        }, travelTime + 500);
                    }
                    
                    game.currentInput = '';
                    mobileInput.value = '';
                    game.targetInvader = null;
                    rotateRocketToTarget(null);
                    updateWordProgress();
                    updateInputDisplay();
                    updateKeyboardHighlight();
                    
                    // Clear all highlights
                    game.invaders.forEach(z => {
                        if (!z.isDying && z.wordElement) {
                            z.wordElement.classList.remove('typing');
                        }
                    });
                    return;
                }
                
                // Update target tracking
                let foundMatch = false;
                let targetInvader = null;
                
                game.invaders.forEach(invader => {
                    if (invader.isDying || !invader.wordElement) return;
                    
                    if (game.currentInput && invader.word.startsWith(game.currentInput)) {
                        if (!foundMatch) {
                            foundMatch = true;
                            targetInvader = invader;
                        }
                    }
                    
                    invader.wordElement.classList.remove('typing');
                });
                
                // Update word progress (character-level green)
                updateWordProgress();
                
                // Store target and rotate rocket
                game.targetInvader = targetInvader;
                rotateRocketToTarget(targetInvader);
                updateInputDisplay();
                updateKeyboardHighlight();
            }
        }

        // Auto-Test Mode
        let autoTestEnabled = false;
        let autoTestInterval = null;
        let speedRoundChecker = null;
        let lastScore = 0;
        
        const autoTestToggle = document.getElementById('autoTestToggle');
        
        autoTestToggle.addEventListener('click', () => {
            autoTestEnabled = !autoTestEnabled;
            
            if (autoTestEnabled) {
                autoTestToggle.style.background = '#10b981';
                autoTestToggle.innerHTML = '<span style="font-size: 14px;">ðŸ¤– ON</span>';
                startAutoTest();
            } else {
                autoTestToggle.style.background = '#3b82f6';
                autoTestToggle.innerHTML = '<span style="font-size: 14px;">ðŸ¤– TEST</span>';
                stopAutoTest();
            }
        });
        
        // Celebration preview button for testing
        const celebrationPreviewBtn = document.getElementById('celebrationPreviewBtn');
        celebrationPreviewBtn.addEventListener('click', () => {
            // Toggle celebration screen
            const celebrationScreen = document.getElementById('celebrationScreen');
            if (celebrationScreen.style.display === 'flex') {
                celebrationScreen.style.display = 'none';
                // Show default top bar again
                document.getElementById('topbar').classList.add('show');
                // Show keyboard again on mobile if it was hidden
                const isMobile = window.matchMedia("(max-width: 768px)").matches;
                if (isMobile && !game.isMathMode) {
                    document.getElementById('onScreenKeyboard').style.display = 'flex';
                }
            } else {
                // Set some sample data for preview
                game.score = Math.floor(Math.random() * 1000);
                game.startTime = Date.now() - (5 * 60 * 1000); // 5 minutes ago
                game.correctCharacters = 250 + Math.floor(Math.random() * 200);
                game.incorrectAttempts = Math.floor(Math.random() * 50);
                game.missedWords = Math.floor(Math.random() * 30);
                
                showCelebration();
            }
        });
        
        function startAutoTest() {
            console.log('ðŸ¤– Auto-Test Mode ENABLED');
            console.log('ðŸ“‹ Test Plan:');
            console.log('  0-199: Normal Mode (words)');
            console.log('  200: Speed Round 1');
            console.log('  300: Speed Round 2');
            console.log('  400: Speed Round 3');
            console.log('  500: Speed Round 4');
            console.log('  600: Speed Round 5');
            console.log('  700: Speed Round 6');
            console.log('  800+: Math Mode');
            console.log('  900+: Letter Mode');
            
            // Auto-start game if not started
            if (!game.isGameOver && gameContainer.classList.contains('hidden')) {
                startGame('easy');
            }
            
            // Monitor score changes and log mode transitions
            speedRoundChecker = setInterval(() => {
                if (game.score !== lastScore) {
                    lastScore = game.score;
                    
                    // Log mode transitions
                    if (game.score === 200 || game.score === 300 || game.score === 400 || 
                        game.score === 500 || game.score === 600 || game.score === 700) {
                        console.log(`ðŸŽ¯ Score ${game.score} - Speed Round triggered!`);
                    } else if (game.score === 800) {
                        console.log('ðŸ§® Score 800 - Math Mode activated!');
                    } else if (game.score === 900) {
                        console.log('â­ Score 900 - Letter Mode activated!');
                    }
                }
                
                // Auto-complete Speed Rounds
                if (game.isChallenge) {
                    const challengeSentence = document.getElementById('challengeSentence');
                    if (challengeSentence) {
                        const targetSentence = challengeSentence.textContent;
                        const remaining = targetSentence.slice(game.currentInput.length);
                        
                        if (remaining.length > 0) {
                            const char = remaining[0];
                            const event = new KeyboardEvent('keydown', {
                                key: char,
                                code: char === ' ' ? 'Space' : `Key${char.toUpperCase()}`,
                                bubbles: true
                            });
                            document.dispatchEvent(event);
                        }
                    }
                }
            }, 100);
            
            // Auto-play the game
            autoTestInterval = setInterval(() => {
                if (game.isGameOver) {
                    console.log('âŒ Game Over - Auto-test completed');
                    stopAutoTest();
                    return;
                }
                
                if (game.isPaused || game.isChallenge) return;
                
                // Find a target invader
                const activeInvaders = game.invaders.filter(inv => !inv.isDying);
                
                if (activeInvaders.length > 0 && game.currentInput === '') {
                    // Pick the invader closest to the bottom (most urgent)
                    const target = activeInvaders.reduce((lowest, inv) => 
                        inv.y > lowest.y ? inv : lowest
                    );
                    
                    // Type the word/answer automatically
                    const word = target.word;
                    
                    console.log(`ðŸŽ¯ Targeting: "${word}" (${target.emoji})`);
                    
                    // Type all characters quickly
                    for (let i = 0; i < word.length; i++) {
                        setTimeout(() => {
                            const char = word[i];
                            const event = new KeyboardEvent('keydown', {
                                key: char,
                                code: char === ' ' ? 'Space' : `Key${char.toUpperCase()}`,
                                bubbles: true
                            });
                            document.dispatchEvent(event);
                        }, i * 30); // 30ms between characters
                    }
                }
            }, 200); // Check for new targets every 200ms
        }
        
        function stopAutoTest() {
            console.log('ðŸ¤– Auto-Test Mode DISABLED');
            if (autoTestInterval) {
                clearInterval(autoTestInterval);
                autoTestInterval = null;
            }
            if (speedRoundChecker) {
                clearInterval(speedRoundChecker);
                speedRoundChecker = null;
            }
            lastScore = 0;
        }

        // Floating words background animation
        function createFloatingWords() {
            const container = document.getElementById('floatingWordsBackground');
            if (!container) return;
            
            // Use same word lists as the game
            const floatingWords = [
                'cat', 'dog', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'eagle',
                'tree', 'rose', 'lily', 'oak', 'pine', 'fern', 'moss', 'vine',
                'atom', 'star', 'moon', 'solar', 'orbit', 'planet', 'galaxy', 'nebula',
                'code', 'type', 'shoot', 'game', 'play', 'win', 'score', 'fast'
            ];
            
            // Spawn words continuously like invaders in the game
            setInterval(() => {
                if (!document.getElementById('timeSelection') || 
                    document.getElementById('timeSelection').classList.contains('hidden')) {
                    return;
                }
                
                const word = floatingWords[Math.floor(Math.random() * floatingWords.length)];
                const wordEl = document.createElement('div');
                wordEl.className = 'floating-word';
                wordEl.textContent = word;
                
                // Estimate width for positioning (will get actual width after append)
                const estimatedWidth = (word.length * 15) + 40;
                const startX = Math.random() * Math.max(100, window.innerWidth - estimatedWidth);
                wordEl.style.left = startX + 'px';
                wordEl.style.top = '-60px';
                
                // Movement speeds matching game invaders (0.8-1.2 speed range for medium difficulty)
                const speedY = 0.8 * (0.8 + Math.random() * 0.4); // pixels per frame
                let speedX = (Math.random() - 0.5) * 0.3; // slight horizontal drift
                
                let posY = -60;
                let posX = startX;
                
                container.appendChild(wordEl);
                
                // Animate like game invaders using requestAnimationFrame
                function animate() {
                    if (!document.getElementById('timeSelection') || 
                        document.getElementById('timeSelection').classList.contains('hidden')) {
                        wordEl.remove();
                        return;
                    }
                    
                    posY += speedY;
                    posX += speedX;
                    
                    // Get actual element width for proper boundary checking
                    const elementWidth = wordEl.offsetWidth || estimatedWidth;
                    
                    // Bounce off edges with proper boundary checking
                    if (posX < 0) {
                        posX = 0;
                        speedX *= -1;
                    } else if (posX + elementWidth > window.innerWidth) {
                        posX = window.innerWidth - elementWidth;
                        speedX *= -1;
                    }
                    
                    wordEl.style.top = posY + 'px';
                    wordEl.style.left = posX + 'px';
                    
                    // Remove when off screen
                    if (posY > window.innerHeight) {
                        wordEl.remove();
                        return;
                    }
                    
                    requestAnimationFrame(animate);
                }
                
                requestAnimationFrame(animate);
                
            }, 2000); // Spawn every 2 seconds like game spawn rate
        }
        
        // Start floating words when page loads
        createFloatingWords();

        // Handle window resize to keep invaders in bounds
        window.addEventListener('resize', () => {
            game.invaders.forEach(invader => {
                if (!invader.isDying && invader.element) {
                    const elementWidth = invader.element.offsetWidth || 100;
                    
                    // Adjust position if out of bounds
                    if (invader.x < 0) {
                        invader.x = 0;
                    } else if (invader.x + elementWidth > window.innerWidth) {
                        invader.x = window.innerWidth - elementWidth;
                    }
                    
                    // Update element position
                    invader.element.style.left = invader.x + 'px';
                }
            });
        });

        // Initialize game - show start screen
        // Game starts when user clicks start button
    </script>
</body>
</html>
